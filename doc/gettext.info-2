This is gettext.info, produced by makeinfo version 4.0 from
gettext.texi.

INFO-DIR-SECTION GNU Gettext Utilities
START-INFO-DIR-ENTRY
* Gettext: (gettext).                           GNU gettext utilities.
* gettextize: (gettext)gettextize Invocation.   Prepare a package for gettext.
* msgfmt: (gettext)msgfmt Invocation.           Make MO files out of PO files.
* msgmerge: (gettext)msgmerge Invocation.       Update two PO files into one.
* xgettext: (gettext)xgettext Invocation.       Extract strings into a PO file.
END-INFO-DIR-ENTRY

   This file provides documentation for GNU `gettext' utilities.  It
also serves as a reference for the free Translation Project.

   Copyright (C) 1995, 1996, 1997, 1998, 2001 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gettext.info,  Node: Entry Positioning,  Next: Normalizing,  Prev: Main PO Commands,  Up: Basics

Entry Positioning
=================

   The cursor in a PO file window is almost always part of an entry.
The only exceptions are the special case when the cursor is after the
last entry in the file, or when the PO file is empty.  The entry where
the cursor is found to be is said to be the current entry.  Many PO
mode commands operate on the current entry, so moving the cursor does
more than allowing the translator to browse the PO file, this also
selects on which entry commands operate.

   Some PO mode commands alter the position of the cursor in a
specialized way.  A few of those special purpose positioning are
described here, the others are described in following sections.

`.'
     Redisplay the current entry.

`n'
`n'
     Select the entry after the current one.

`p'
`p'
     Select the entry before the current one.

`<'
     Select the first entry in the PO file.

`>'
     Select the last entry in the PO file.

`m'
     Record the location of the current entry for later use.

`l'
     Return to a previously saved entry location.

`x'
     Exchange the current entry location with the previously saved one.

   Any Emacs command able to reposition the cursor may be used to
select the current entry in PO mode, including commands which move by
characters, lines, paragraphs, screens or pages, and search commands.
However, there is a kind of standard way to display the current entry
in PO mode, which usual Emacs commands moving the cursor do not
especially try to enforce.  The command `.' (`po-current-entry') has
the sole purpose of redisplaying the current entry properly, after the
current entry has been changed by means external to PO mode, or the
Emacs screen otherwise altered.

   It is yet to be decided if PO mode helps the translator, or otherwise
irritates her, by forcing a rigid window disposition while she is doing
her work.  We originally had quite precise ideas about how windows
should behave, but on the other hand, anyone used to Emacs is often
happy to keep full control.  Maybe a fixed window disposition might be
offered as a PO mode option that the translator might activate or
deactivate at will, so it could be offered on an experimental basis.
If nobody feels a real need for using it, or a compulsion for writing
it, we should drop this whole idea.  The incentive for doing it should
come from translators rather than programmers, as opinions from an
experienced translator are surely more worth to me than opinions from
programmers _thinking_ about how _others_ should do translation.

   The commands `n' (`po-next-entry') and `p' (`po-previous-entry')
move the cursor the entry following, or preceding, the current one.  If
`n' is given while the cursor is on the last entry of the PO file, or
if `p' is given while the cursor is on the first entry, no move is done.

   The commands `<' (`po-first-entry') and `>' (`po-last-entry') move
the cursor to the first entry, or last entry, of the PO file.  When the
cursor is located past the last entry in a PO file, most PO mode
commands will return an error saying `After last entry'.  Moreover, the
commands `<' and `>' have the special property of being able to work
even when the cursor is not into some PO file entry, and one may use
them for nicely correcting this situation.  But even these commands
will fail on a truly empty PO file.  There are development plans for
the PO mode for it to interactively fill an empty PO file from sources.
*Note Marking::.

   The translator may decide, before working at the translation of a
particular entry, that she needs to browse the remainder of the PO
file, maybe for finding the terminology or phraseology used in related
entries.  She can of course use the standard Emacs idioms for saving
the current cursor location in some register, and use that register for
getting back, or else, use the location ring.

   PO mode offers another approach, by which cursor locations may be
saved onto a special stack.  The command `m' (`po-push-location')
merely adds the location of current entry to the stack, pushing the
already saved locations under the new one.  The command `r'
(`po-pop-location') consumes the top stack element and repositions the
cursor to the entry associated with that top element.  This position is
then lost, for the next `r' will move the cursor to the previously
saved location, and so on until no locations remain on the stack.

   If the translator wants the position to be kept on the location
stack, maybe for taking a look at the entry associated with the top
element, then go elsewhere with the intent of getting back later, she
ought to use `m' immediately after `r'.

   The command `x' (`po-exchange-location') simultaneously repositions
the cursor to the entry associated with the top element of the stack of
saved locations, and replaces that top element with the location of the
current entry before the move.  Consequently, repeating the `x' command
toggles alternatively between two entries.  For achieving this, the
translator will position the cursor on the first entry, use `m', then
position to the second entry, and merely use `x' for making the switch.


File: gettext.info,  Node: Normalizing,  Prev: Entry Positioning,  Up: Basics

Normalizing Strings in Entries
==============================

   There are many different ways for encoding a particular string into a
PO file entry, because there are so many different ways to split and
quote multi-line strings, and even, to represent special characters by
backslahsed escaped sequences.  Some features of PO mode rely on the
ability for PO mode to scan an already existing PO file for a
particular string encoded into the `msgid' field of some entry.  Even
if PO mode has internally all the built-in machinery for implementing
this recognition easily, doing it fast is technically difficult.  To
facilitate a solution to this efficiency problem, we decided on a
canonical representation for strings.

   A conventional representation of strings in a PO file is currently
under discussion, and PO mode experiments with a canonical
representation.  Having both `xgettext' and PO mode converging towards
a uniform way of representing equivalent strings would be useful, as
the internal normalization needed by PO mode could be automatically
satisfied when using `xgettext' from GNU `gettext'.  An explicit PO
mode normalization should then be only necessary for PO files imported
from elsewhere, or for when the convention itself evolves.

   So, for achieving normalization of at least the strings of a given
PO file needing a canonical representation, the following PO mode
command is available:

`M-x po-normalize'
     Tidy the whole PO file by making entries more uniform.

   The special command `M-x po-normalize', which has no associated
keys, revises all entries, ensuring that strings of both original and
translated entries use uniform internal quoting in the PO file.  It
also removes any crumb after the last entry.  This command may be
useful for PO files freshly imported from elsewhere, or if we ever
improve on the canonical quoting format we use.  This canonical format
is not only meant for getting cleaner PO files, but also for greatly
speeding up `msgid' string lookup for some other PO mode commands.

   `M-x po-normalize' presently makes three passes over the entries.
The first implements heuristics for converting PO files for GNU
`gettext' 0.6 and earlier, in which `msgid' and `msgstr' fields were
using K&R style C string syntax for multi-line strings.  These
heuristics may fail for comments not related to obsolete entries and
ending with a backslash; they also depend on subsequent passes for
finalizing the proper commenting of continued lines for obsolete
entries.  This first pass might disappear once all oldish PO files
would have been adjusted.  The second and third pass normalize all
`msgid' and `msgstr' strings respectively.  They also clean out those
trailing backslashes used by XView's `msgfmt' for continued lines.

   Having such an explicit normalizing command allows for importing PO
files from other sources, but also eases the evolution of the current
convention, evolution driven mostly by aesthetic concerns, as of now.
It is easy to make suggested adjustments at a later time, as the
normalizing command and eventually, other GNU `gettext' tools should
greatly automate conformance.  A description of the canonical string
format is given below, for the particular benefit of those not having
Emacs handy, and who would nevertheless want to handcraft their PO
files in nice ways.

   Right now, in PO mode, strings are single line or multi-line.  A
string goes multi-line if and only if it has _embedded_ newlines, that
is, if it matches `[^\n]\n+[^\n]'.  So, we would have:

     msgstr "\n\nHello, world!\n\n\n"

   but, replacing the space by a newline, this becomes:

     msgstr ""
     "\n"
     "\n"
     "Hello,\n"
     "world!\n"
     "\n"
     "\n"

   We are deliberately using a caricatural example, here, to make the
point clearer.  Usually, multi-lines are not that bad looking.  It is
probable that we will implement the following suggestion.  We might
lump together all initial newlines into the empty string, and also all
newlines introducing empty lines (that is, for N > 1, the N-1'th last
newlines would go together on a separate string), so making the
previous example appear:

     msgstr "\n\n"
     "Hello,\n"
     "world!\n"
     "\n\n"

   There are a few yet undecided little points about string
normalization, to be documented in this manual, once these questions
settle.


File: gettext.info,  Node: Sources,  Next: Template,  Prev: Basics,  Up: Top

Preparing Program Sources
*************************

   For the programmer, changes to the C source code fall into three
categories.  First, you have to make the localization functions known
to all modules needing message translation.  Second, you should
properly trigger the operation of GNU `gettext' when the program
initializes, usually from the `main' function.  Last, you should
identify and especially mark all constant strings in your program
needing translation.

   Presuming that your set of programs, or package, has been adjusted
so all needed GNU `gettext' files are available, and your `Makefile'
files are adjusted (*note Maintainers::), each C module having
translated C strings should contain the line:

     #include <libintl.h>

   The remaining changes to your C sources are discussed in the further
sections of this chapter.

* Menu:

* Triggering::                  Triggering `gettext' Operations
* Mark Keywords::               How Marks Appear in Sources
* Marking::                     Marking Translatable Strings
* c-format::                    Telling something about the following string
* Special cases::               Special Cases of Translatable Strings


File: gettext.info,  Node: Triggering,  Next: Mark Keywords,  Prev: Sources,  Up: Sources

Triggering `gettext' Operations
===============================

   The initialization of locale data should be done with more or less
the same code in every program, as demonstrated below:

     int
     main (argc, argv)
          int argc;
          char argv;
     {
       ...
       setlocale (LC_ALL, "");
       bindtextdomain (PACKAGE, LOCALEDIR);
       textdomain (PACKAGE);
       ...
     }

   PACKAGE and LOCALEDIR should be provided either by `config.h' or by
the Makefile.  For now consult the `gettext' sources for more
information.

   The use of `LC_ALL' might not be appropriate for you.  `LC_ALL'
includes all locale categories and especially `LC_CTYPE'.  This later
category is responsible for determining character classes with the
`isalnum' etc. functions from `ctype.h' which could especially for
programs, which process some kind of input language, be wrong.  For
example this would mean that a source code using the c, (c-cedilla
character) is runnable in France but not in the U.S.

   Some systems also have problems with parsing numbers using the
`scanf' functions if an other but the `LC_ALL' locale is used.  The
standards say that additional formats but the one known in the `"C"'
locale might be recognized.  But some systems seem to reject numbers in
the `"C"' locale format.  In some situation, it might also be a problem
with the notation itself which makes it impossible to recognize whether
the number is in the `"C"' locale or the local format.  This can happen
if thousands separator characters are used.  Some locales define this
character accordfing to the national conventions to `'.'' which is the
same character used in the `"C"' locale to denote the decimal point.

   So it is sometimes necessary to replace the `LC_ALL' line in the
code above by a sequence of `setlocale' lines

     {
       ...
       setlocale (LC_CTYPE, "");
       setlocale (LC_MESSAGES, "");
       ...
     }

On all POSIX conformant systems the locale categories `LC_CTYPE',
`LC_COLLATE', `LC_MONETARY', `LC_NUMERIC', and `LC_TIME' are available.
On some modern systems there is also a locale `LC_MESSAGES' which is
called on some old, XPG2 compliant systems `LC_RESPONSES'.

   Note that changing the `LC_CTYPE' also affects the functions
declared in the `<ctype.h>' standard header.  If this is not desirable
in your application (for example in a compiler's parser), you can use a
set of substitute functions which hardwire the C locale, such as found
in the `<c-ctype.h>' and `<c-ctype.c>' files in the gettext source
distribution.

   It is also possible to switch the locale forth and back between the
environment dependent locale and the C locale, but this approach is
normally avoided because a `setlocale' call is expensive, because it is
tedious to determine the places where a locale switch is needed in a
large program's source, and because switching a locale is not
multithread-safe.


File: gettext.info,  Node: Mark Keywords,  Next: Marking,  Prev: Triggering,  Up: Sources

How Marks Appear in Sources
===========================

   All strings requiring translation should be marked in the C sources.
Marking is done in such a way that each translatable string appears to
be the sole argument of some function or preprocessor macro.  There are
only a few such possible functions or macros meant for translation, and
their names are said to be marking keywords.  The marking is attached
to strings themselves, rather than to what we do with them.  This
approach has more uses.  A blatant example is an error message produced
by formatting.  The format string needs translation, as well as some
strings inserted through some `%s' specification in the format, while
the result from `sprintf' may have so many different instances that it
is impractical to list them all in some `error_string_out()' routine,
say.

   This marking operation has two goals.  The first goal of marking is
for triggering the retrieval of the translation, at run time.  The
keyword are possibly resolved into a routine able to dynamically return
the proper translation, as far as possible or wanted, for the argument
string.  Most localizable strings are found in executable positions,
that is, attached to variables or given as parameters to functions.
But this is not universal usage, and some translatable strings appear
in structured initializations.  *Note Special cases::.

   The second goal of the marking operation is to help `xgettext' at
properly extracting all translatable strings when it scans a set of
program sources and produces PO file templates.

   The canonical keyword for marking translatable strings is `gettext',
it gave its name to the whole GNU `gettext' package.  For packages
making only light use of the `gettext' keyword, macro or function, it
is easily used _as is_.  However, for packages using the `gettext'
interface more heavily, it is usually more convenient to give the main
keyword a shorter, less obtrusive name.  Indeed, the keyword might
appear on a lot of strings all over the package, and programmers
usually do not want nor need their program sources to remind them
forcefully, all the time, that they are internationalized.  Further, a
long keyword has the disadvantage of using more horizontal space,
forcing more indentation work on sources for those trying to keep them
within 79 or 80 columns.

   Many packages use `_' (a simple underline) as a keyword, and write
`_("Translatable string")' instead of `gettext ("Translatable
string")'.  Further, the coding rule, from GNU standards, wanting that
there is a space between the keyword and the opening parenthesis is
relaxed, in practice, for this particular usage.  So, the textual
overhead per translatable string is reduced to only three characters:
the underline and the two parentheses.  However, even if GNU `gettext'
uses this convention internally, it does not offer it officially.  The
real, genuine keyword is truly `gettext' indeed.  It is fairly easy for
those wanting to use `_' instead of `gettext' to declare:

     #include <libintl.h>
     #define _(String) gettext (String)

instead of merely using `#include <libintl.h>'.

   Later on, the maintenance is relatively easy.  If, as a programmer,
you add or modify a string, you will have to ask yourself if the new or
altered string requires translation, and include it within `_()' if you
think it should be translated.  `"%s: %d"' is an example of string
_not_ requiring translation!


File: gettext.info,  Node: Marking,  Next: c-format,  Prev: Mark Keywords,  Up: Sources

Marking Translatable Strings
============================

   In PO mode, one set of features is meant more for the programmer than
for the translator, and allows him to interactively mark which strings,
in a set of program sources, are translatable, and which are not.  Even
if it is a fairly easy job for a programmer to find and mark such
strings by other means, using any editor of his choice, PO mode makes
this work more comfortable.  Further, this gives translators who feel a
little like programmers, or programmers who feel a little like
translators, a tool letting them work at marking translatable strings
in the program sources, while simultaneously producing a set of
translation in some language, for the package being internationalized.

   The set of program sources, targetted by the PO mode commands
describe here, should have an Emacs tags table constructed for your
project, prior to using these PO file commands.  This is easy to do.
In any shell window, change the directory to the root of your project,
then execute a command resembling:

     etags src/*.[hc] lib/*.[hc]

presuming here you want to process all `.h' and `.c' files from the
`src/' and `lib/' directories.  This command will explore all said
files and create a `TAGS' file in your root directory, somewhat
summarizing the contents using a special file format Emacs can
understand.

   For packages following the GNU coding standards, there is a make
goal `tags' or `TAGS' which constructs the tag files in all directories
and for all files containing source code.

   Once your `TAGS' file is ready, the following commands assist the
programmer at marking translatable strings in his set of sources.  But
these commands are necessarily driven from within a PO file window, and
it is likely that you do not even have such a PO file yet.  This is not
a problem at all, as you may safely open a new, empty PO file, mainly
for using these commands.  This empty PO file will slowly fill in while
you mark strings as translatable in your program sources.

`,'
     Search through program sources for a string which looks like a
     candidate for translation.

`M-,'
     Mark the last string found with `_()'.

`M-.'
     Mark the last string found with a keyword taken from a set of
     possible keywords.  This command with a prefix allows some
     management of these keywords.

   The `,' (`po-tags-search') command searches for the next occurrence
of a string which looks like a possible candidate for translation, and
displays the program source in another Emacs window, positioned in such
a way that the string is near the top of this other window.  If the
string is too big to fit whole in this window, it is positioned so only
its end is shown.  In any case, the cursor is left in the PO file
window.  If the shown string would be better presented differently in
different native languages, you may mark it using `M-,' or `M-.'.
Otherwise, you might rather ignore it and skip to the next string by
merely repeating the `,' command.

   A string is a good candidate for translation if it contains a
sequence of three or more letters.  A string containing at most two
letters in a row will be considered as a candidate if it has more
letters than non-letters.  The command disregards strings containing no
letters, or isolated letters only.  It also disregards strings within
comments, or strings already marked with some keyword PO mode knows
(see below).

   If you have never told Emacs about some `TAGS' file to use, the
command will request that you specify one from the minibuffer, the
first time you use the command.  You may later change your `TAGS' file
by using the regular Emacs command `M-x visit-tags-table', which will
ask you to name the precise `TAGS' file you want to use.  *Note Tag
Tables: (emacs)Tags.

   Each time you use the `,' command, the search resumes from where it
was left by the previous search, and goes through all program sources,
obeying the `TAGS' file, until all sources have been processed.
However, by giving a prefix argument to the command (`C-u ,'), you may
request that the search be restarted all over again from the first
program source; but in this case, strings that you recently marked as
translatable will be automatically skipped.

   Using this `,' command does not prevent using of other regular Emacs
tags commands.  For example, regular `tags-search' or
`tags-query-replace' commands may be used without disrupting the
independent `,' search sequence.  However, as implemented, the
_initial_ `,' command (or the `,' command is used with a prefix) might
also reinitialize the regular Emacs tags searching to the first tags
file, this reinitialization might be considered spurious.

   The `M-,' (`po-mark-translatable') command will mark the recently
found string with the `_' keyword.  The `M-.'
(`po-select-mark-and-mark') command will request that you type one
keyword from the minibuffer and use that keyword for marking the
string.  Both commands will automatically create a new PO file
untranslated entry for the string being marked, and make it the current
entry (making it easy for you to immediately proceed to its
translation, if you feel like doing it right away).  It is possible
that the modifications made to the program source by `M-,' or `M-.'
render some source line longer than 80 columns, forcing you to break
and re-indent this line differently.  You may use the `O' command from
PO mode, or any other window changing command from Emacs, to break out
into the program source window, and do any needed adjustments.  You
will have to use some regular Emacs command to return the cursor to the
PO file window, if you want command `,' for the next string, say.

   The `M-.' command has a few built-in speedups, so you do not have to
explicitly type all keywords all the time.  The first such speedup is
that you are presented with a _preferred_ keyword, which you may accept
by merely typing `<RET>' at the prompt.  The second speedup is that you
may type any non-ambiguous prefix of the keyword you really mean, and
the command will complete it automatically for you.  This also means
that PO mode has to _know_ all your possible keywords, and that it will
not accept mistyped keywords.

   If you reply `?' to the keyword request, the command gives a list of
all known keywords, from which you may choose.  When the command is
prefixed by an argument (`C-u M-.'), it inhibits updating any program
source or PO file buffer, and does some simple keyword management
instead.  In this case, the command asks for a keyword, written in
full, which becomes a new allowed keyword for later `M-.' commands.
Moreover, this new keyword automatically becomes the _preferred_
keyword for later commands.  By typing an already known keyword in
response to `C-u M-.', one merely changes the _preferred_ keyword and
does nothing more.

   All keywords known for `M-.' are recognized by the `,' command when
scanning for strings, and strings already marked by any of those known
keywords are automatically skipped.  If many PO files are opened
simultaneously, each one has its own independent set of known keywords.
There is no provision in PO mode, currently, for deleting a known
keyword, you have to quit the file (maybe using `q') and reopen it
afresh.  When a PO file is newly brought up in an Emacs window, only
`gettext' and `_' are known as keywords, and `gettext' is preferred for
the `M-.' command.  In fact, this is not useful to prefer `_', as this
one is already built in the `M-,' command.


File: gettext.info,  Node: c-format,  Next: Special cases,  Prev: Marking,  Up: Sources

Special Comments preceding Keywords
===================================

   In C programs strings are often used within calls of functions from
the `printf' family.  The special thing about these format strings is
that they can contain format specifiers introduced with `%'.  Assume we
have the code

     printf (gettext ("String `%s' has %d characters\n"), s, strlen (s));

A possible German translation for the above string might be:

     "%d Zeichen lang ist die Zeichenkette `%s'"

   A C programmer, even if he cannot speak German, will recognize that
there is something wrong here.  The order of the two format specifiers
is changed but of course the arguments in the `printf' don't have.
This will most probably lead to problems because now the length of the
string is regarded as the address.

   To prevent errors at runtime caused by translations the `msgfmt'
tool can check statically whether the arguments in the original and the
translation string match in type and number.  If this is not the case a
warning will be given and the error cannot causes problems at runtime.

If the word order in the above German translation would be correct one
would have to write

     "%2$d Zeichen lang ist die Zeichenkette `%1$s'"

The routines in `msgfmt' know about this special notation.

   Because not all strings in a program must be format strings it is not
useful for `msgfmt' to test all the strings in the `.po' file.  This
might cause problems because the string might contain what looks like a
format specifier, but the string is not used in `printf'.

   Therefore the `xgettext' adds a special tag to those messages it
thinks might be a format string.  There is no absolute rule for this,
only a heuristic.  In the `.po' file the entry is marked using the
`c-format' flag in the `#,' comment line (*note PO Files::).

   The careful reader now might say that this again can cause problems.
The heuristic might guess it wrong.  This is true and therefore
`xgettext' knows about special kind of comment which lets the
programmer take over the decision.  If in the same line or the
immediately preceding line of the `gettext' keyword the `xgettext'
program find a comment containing the words `xgettext:c-format' it will
mark the string in any case with the `c-format' flag.  This kind of
comment should be used when `xgettext' does not recognize the string as
a format string but is really is one and it should be tested.  Please
note that when the comment is in the same line of the `gettext'
keyword, it must be before the string to be translated.

   This situation happens quite often.  The `printf' function is often
called with strings which do not contain a format specifier.  Of course
one would normally use `fputs' but it does happen.  In this case
`xgettext' does not recognize this as a format string but what happens
if the translation introduces a valid format specifier?  The `printf'
function will try to access one of the parameter but none exists
because the original code does not refer to any parameter.

   `xgettext' of course could make a wrong decision the other way
round, i.e. a string marked as a format string actually is not a format
string.  In this case the `msgfmt' might give too many warnings and
would prevent translating the `.po' file.  The method to prevent this
wrong decision is similar to the one used above, only the comment to
use must contain the string `xgettext:no-c-format'.

   If a string is marked with `c-format' and this is not correct the
user can find out who is responsible for the decision.  See *Note
xgettext Invocation:: to see how the `--debug' option can be used for
solving this problem.


File: gettext.info,  Node: Special cases,  Prev: c-format,  Up: Sources

Special Cases of Translatable Strings
=====================================

   The attentive reader might now point out that it is not always
possible to mark translatable string with `gettext' or something like
this.  Consider the following case:

     {
       static const char *messages[] = {
         "some very meaningful message",
         "and another one"
       };
       const char *string;
       ...
       string
         = index > 1 ? "a default message" : messages[index];
     
       fputs (string);
       ...
     }

   While it is no problem to mark the string `"a default message"' it
is not possible to mark the string initializers for `messages'.  What
is to be done?  We have to fulfill two tasks.  First we have to mark the
strings so that the `xgettext' program (*note xgettext Invocation::)
can find them, and second we have to translate the string at runtime
before printing them.

   The first task can be fulfilled by creating a new keyword, which
names a no-op.  For the second we have to mark all access points to a
string from the array.  So one solution can look like this:

     #define gettext_noop(String) (String)
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message"),
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext ("a default message") : gettext (messages[index]);
     
       fputs (string);
       ...
     }

   Please convince yourself that the string which is written by `fputs'
is translated in any case.  How to get `xgettext' know the additional
keyword `gettext_noop' is explained in *Note xgettext Invocation::.

   The above is of course not the only solution.  You could also come
along with the following one:

     #define gettext_noop(String) (String)
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message",
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext_noop ("a default message") : messages[index];
     
       fputs (gettext (string));
       ...
     }

   But this has some drawbacks.  First the programmer has to take care
that he uses `gettext_noop' for the string `"a default message"'.  A
use of `gettext' could have in rare cases unpredictable results.  The
second reason is found in the internals of the GNU `gettext' Library
which will make this solution less efficient.

   One advantage is that you need not make control flow analysis to make
sure the output is really translated in any case.  But this analysis is
generally not very difficult.  If it should be in any situation you can
use this second method in this situation.


File: gettext.info,  Node: Template,  Next: Creating,  Prev: Sources,  Up: Top

Making the PO Template File
***************************

   After preparing the sources, the programmer creates a PO template
file.  This section explains how to use `xgettext' for this purpose.

* Menu:

* xgettext Invocation::         Invoking the `xgettext' Program


File: gettext.info,  Node: xgettext Invocation,  Prev: Template,  Up: Template

Invoking the `xgettext' Program
===============================

     xgettext [OPTION] INPUTFILE ...

`-a'
`--extract-all'
     Extract all strings.

`-c [TAG]'
`--add-comments[=TAG]'
     Place comment block with TAG (or those preceding keyword lines) in
     output file.

`-C'
`--c++'
     Recognize C++ style comments.

`--debug'
     Use the flags `c-format' and `possible-c-format' to show who was
     responsible for marking a message as a format string.  The latter
     form is used if the `xgettext' program decided, the format form is
     used if the programmer prescribed it.

     By default only the `c-format' form is used.  The translator should
     not have to care about these details.

`-d NAME'
`--default-domain=NAME'
     Use `NAME.po' for output (instead of `messages.po').

     The special domain name `-' or `/dev/stdout' means to write the
     output to `stdout'.

`-D DIRECTORY'
`--directory=DIRECTORY'
     Change to DIRECTORY before beginning to search and scan source
     files.  The resulting `.po' file will be written relative to the
     original directory, though.

`-f FILE'
`--files-from=FILE'
     Read the names of the input files from FILE instead of getting
     them from the command line.

`--force'
     Always write an output file even if no message is defined.

`-h'
`--help'
     Display this help and exit.

`-I LIST'
`--input-path=LIST'
     List of directories searched for input files.

`-j'
`--join-existing'
     Join messages with existing file.

`-k WORD'
`--keyword[=KEYWORDSPEC]'
     Additional keyword to be looked for (without KEYWORDSPEC means not
     to use default keywords).

     If KEYWORDSPEC is a C identifer ID, `xgettext' looks for strings
     in the first argument of each call to the function or macro ID.
     If KEYWORDSPEC is of the form `ID:ARGNUM', `xgettext' looks for
     strings in the ARGNUMth argument of the call.  If KEYWORDSPEC is
     of the form `ID:ARGNUM1,ARGNUM2', `xgettext' looks for strings in
     the ARGNUM1st argument and in the ARGNUM2nd argument of the call,
     and treats them as singular/plural variants for a message with
     plural handling.

     The default keyword specifications, which are always looked for if
     not explicitly disabled, are `gettext', `dgettext:2',
     `dcgettext:2', `ngettext:1,2', `dngettext:2,3', `dcngettext:2,3',
     and `gettext_noop'.

`-m [STRING]'
`--msgstr-prefix[=STRING]'
     Use STRING or "" as prefix for msgstr entries.

`-M [STRING]'
`--msgstr-suffix[=STRING]'
     Use STRING or "" as suffix for msgstr entries.

`--no-location'
     Do not write `#: FILENAME:LINE' lines.

`-n'
`--add-location'
     Generate `#: FILENAME:LINE' lines (default).

`--omit-header'
     Don't write header with `msgid ""' entry.

     This is useful for testing purposes because it eliminates a source
     of variance for generated `.gmo' files.  We can ship some of these
     files in the GNU `gettext' package, and the result of regenerating
     them through `msgfmt' should yield the same values.

`-p DIR'
`--output-dir=DIR'
     Output files will be placed in directory DIR.

`-s'
`--sort-output'
     Generate sorted output and remove duplicates.

`--strict'
     Write out a strict Uniforum conforming PO file.

`-v'
`--version'
     Output version information and exit.

`-x FILE'
`--exclude-file=FILE'
     Entries from FILE are not extracted.

   Search path for supplementary PO files is:
`/usr/local/share/nls/src/'.

   If INPUTFILE is `-', standard input is read.

   This implementation of `xgettext' is able to process a few awkward
cases, like strings in preprocessor macros, ANSI concatenation of
adjacent strings, and escaped end of lines for continued strings.


File: gettext.info,  Node: Creating,  Next: Updating,  Prev: Template,  Up: Top

Creating a New PO File
**********************

   When starting a new translation, the translator copies the
`PACKAGE.pot' template file to a file called `LANG.po'.  Then she
modifies the initial comments and the header entry of this file.

   The initial comments "SOME DESCRIPTIVE TITLE", "YEAR" and "FIRST
AUTHOR <EMAIL@ADDRESS>, YEAR" ought to be replaced by sensible
information.  This can be done in any text editor; if Emacs is used and
it switched to PO mode automatically (because it has recognized the
file's suffix), you can disable it by typing `M-x fundamental-mode'.

   Modifying the header entry can already be done using PO mode: in
Emacs, type `M-x po-mode RET' and then `RET' again to start editing the
entry.  You should fill in the following fields.

Project-Id-Version
     This is the name and version of the package.

POT-Creation-Date
     This has already been filled in by `xgettext'.

PO-Revision-Date
     You don't need to fill this in. It will be filled by the Emacs PO
     mode when you save the file.

Last-Translator
     Fill in your name and email address (without double quotes).

Language-Team
     Fill in the English name of the language, and the email address of
     the language team you are part of.

     Before starting a translation, it is a good idea to get in touch
     with your translation team, not only to make sure you don't do
     duplicated work, but also to coordinate difficult linguistic
     issues.

     In the Free Translation Project, each translation team has its own
     mailing list.  The up-to-date list of teams can be found at the
     Free Translation Project's homepage,
     `http://www.iro.umontreal.ca/contrib/po/HTML/', in the "National
     teams" area.

Content-Type
     Replace `CHARSET' with the character encoding used for your
     language, in your locale, or UTF-8.  This field is needed for
     correct operation of the `msgmerge' and `msgfmt' programs, as well
     as for users whose locale's character encoding differs from yours
     (see *Note Charset conversion::).

     You get the character encoding of your locale by running the shell
     command `locale charmap'.  If the result is `C' or
     `ANSI_X3.4-1968', which is equivalent to `ASCII' (= `US-ASCII'),
     it means that your locale is not correctly configured.  In this
     case, ask your translation team which charset to use.  `ASCII' is
     not usable for any language except Latin.

     Because the PO files must be portable to operating systems with
     less advanced internationalization facilities, the character
     encodings that can be used are limited to those supported by both
     GNU `libc' and GNU `libiconv'. These are: `ASCII', `ISO-8859-1',
     `ISO-8859-2', `ISO-8859-3', `ISO-8859-4', `ISO-8859-5',
     `ISO-8859-6', `ISO-8859-7', `ISO-8859-8', `ISO-8859-9',
     `ISO-8859-13', `ISO-8859-15', `KOI8-R', `KOI8-U', `CP850',
     `CP866', `CP874', `CP932', `CP949', `CP950', `CP1250', `CP1251',
     `CP1252', `CP1253', `CP1254', `CP1255', `CP1256', `CP1257',
     `GB2312', `EUC-JP', `EUC-KR', `EUC-TW', `BIG5', `BIG5-HKSCS',
     `GBK', `GB18030', `SHIFT_JIS', `JOHAB', `TIS-620', `VISCII',
     `UTF-8'.

     In the GNU system, the following encodings are frequently used for
     the corresponding languages.

        * `ISO-8859-1' for  Afrikaans, Albanian, Basque, Catalan,
          Dutch, English, Estonian, Faroese,  Finnish, French,
          Galician, German, Greenlandic, Icelandic, Indonesian,  Irish,
          Italian, Malay, Norwegian, Portuguese, Spanish, Swedish,

        * `ISO-8859-2' for  Croatian, Czech, Hungarian, Polish,
          Romanian, Serbian, Slovak, Slovenian,

        * `ISO-8859-3' for Maltese,

        * `ISO-8859-5' for Macedonian, Serbian,

        * `ISO-8859-6' for Arabic,

        * `ISO-8859-7' for Greek,

        * `ISO-8859-8' for Hebrew,

        * `ISO-8859-9' for Turkish,

        * `ISO-8859-13' for Latvian, Lithuanian,

        * `ISO-8859-15' for  Basque, Catalan, Dutch, English, Finnish,
          French, Galician, German, Irish,  Italian, Portuguese,
          Spanish, Swedish,

        * `KOI8-R' for Russian,

        * `KOI8-U' for Ukrainian,

        * `CP1251' for Bulgarian, Byelorussian,

        * `GB2312', `GBK', `GB18030'  for simplified writing of Chinese,

        * `BIG5', `BIG5-HKSCS'  for traditional writing of Chinese,

        * `EUC-JP' for Japanese,

        * `EUC-KR' for Korean,

        * `TIS-620' for Thai,

        * `UTF-8' for any language, including those listed above.

     When single quote characters or double quote characters are used in
     translations for your language, and your locale's encoding is one
     of the ISO-8859-* charsets, it is best if you create your PO files
     in UTF-8 encoding, instead of your locale's encoding.  This is
     because in UTF-8 the real quote characters can be represented
     (single quote characters: U+2018, U+2019, double quote characters:
     U+201C, U+201D), whereas none of ISO-8859-* charsets has them all.
     Users in UTF-8 locales will see the real quote characters,
     whereas users in ISO-8859-* locales will see the vertical
     apostrophe and the vertical double quote instead (because that's
     what the character set conversion will transliterate them to).

     To enter such quote characters under X11, you can change your
     keyboard mapping using the `xmodmap' program.  The X11 names of
     the quote characters are "leftsinglequotemark",
     "rightsinglequotemark", "leftdoublequotemark",
     "rightdoublequotemark", "singlelowquotemark", "doublelowquotemark".

     Note that only recent versions of GNU Emacs support the UTF-8
     encoding: Emacs 20 with Mule-UCS, and Emacs 21.  As of January
     2001, XEmacs doesn't support the UTF-8 encoding.

     The character encoding name can be written in either upper or
     lower case.  Usually upper case is preferred.

Content-Transfer-Encoding
     Set this to `8bit'.

Plural-Forms
     This field is optional.  It is only needed if the PO file has
     plural forms.  You can find them by searching for the
     `msgid_plural' keyword.  The format of the plural forms field is
     described in *Note Plural forms::.


File: gettext.info,  Node: Updating,  Next: Binaries,  Prev: Creating,  Up: Top

Updating Existing PO Files
**************************

* Menu:

* msgmerge Invocation::         Invoking the `msgmerge' Program
* Translated Entries::          Translated Entries
* Fuzzy Entries::               Fuzzy Entries
* Untranslated Entries::        Untranslated Entries
* Obsolete Entries::            Obsolete Entries
* Modifying Translations::      Modifying Translations
* Modifying Comments::          Modifying Comments
* Subedit::                     Mode for Editing Translations
* C Sources Context::           C Sources Context
* Auxiliary::                   Consulting Auxiliary PO Files
* Compendium::                  Using Translation Compendiums


File: gettext.info,  Node: msgmerge Invocation,  Next: Translated Entries,  Prev: Updating,  Up: Updating

Invoking the `msgmerge' Program
===============================


File: gettext.info,  Node: Translated Entries,  Next: Fuzzy Entries,  Prev: msgmerge Invocation,  Up: Updating

Translated Entries
==================

   Each PO file entry for which the `msgstr' field has been filled with
a translation, and which is not marked as fuzzy (*note Fuzzy Entries::),
is a said to be a "translated" entry.  Only translated entries will
later be compiled by GNU `msgfmt' and become usable in programs.  Other
entry types will be excluded; translation will not occur for them.

   Some commands are more specifically related to translated entry
processing.

`t'
     Find the next translated entry.

`M-t'
     Find the previous translated entry.

   The commands `t' (`po-next-translated-entry') and `M-t'
(`po-previous-transted-entry') move forwards or backwards, chasing for
an translated entry.  If none is found, the search is extended and
wraps around in the PO file buffer.

   Translated entries usually result from the translator having edited
in a translation for them, *Note Modifying Translations::.  However, if
the variable `po-auto-fuzzy-on-edit' is not `nil', the entry having
received a new translation first becomes a fuzzy entry, which ought to
be later unfuzzied before becoming an official, genuine translated
entry.  *Note Fuzzy Entries::.


File: gettext.info,  Node: Fuzzy Entries,  Next: Untranslated Entries,  Prev: Translated Entries,  Up: Updating

Fuzzy Entries
=============

   Each PO file entry may have a set of "attributes", which are
qualities given a name and explicitely associated with the translation,
using a special system comment.  One of these attributes has the name
`fuzzy', and entries having this attribute are said to have a fuzzy
translation.  They are called fuzzy entries, for short.

   Fuzzy entries, even if they account for translated entries for most
other purposes, usually call for revision by the translator.  Those may
be produced by applying the program `msgmerge' to update an older
translated PO files according to a new PO template file, when this tool
hypothesises that some new `msgid' has been modified only slightly out
of an older one, and chooses to pair what it thinks to be the old
translation for the new modified entry.  The slight alteration in the
original string (the `msgid' string) should often be reflected in the
translated string, and this requires the intervention of the
translator.  For this reason, `msgmerge' might mark some entries as
being fuzzy.

   Also, the translator may decide herself to mark an entry as fuzzy
for her own convenience, when she wants to remember that the entry has
to be later revisited.  So, some commands are more specifically related
to fuzzy entry processing.

`f'
     Find the next fuzzy entry.

`M-f'
     Find the previous fuzzy entry.

`<TAB>'
     Remove the fuzzy attribute of the current entry.

   The commands `f' (`po-next-fuzzy') and `M-f' (`po-previous-fuzzy')
move forwards or backwards, chasing for a fuzzy entry.  If none is
found, the search is extended and wraps around in the PO file buffer.

   The command `<TAB>' (`po-unfuzzy') removes the fuzzy attribute
associated with an entry, usually leaving it translated.  Further, if
the variable `po-auto-select-on-unfuzzy' has not the `nil' value, the
`<TAB>' command will automatically chase for another interesting entry
to work on.  The initial value of `po-auto-select-on-unfuzzy' is `nil'.

   The initial value of `po-auto-fuzzy-on-edit' is `nil'.  However, if
the variable `po-auto-fuzzy-on-edit' is set to `t', any entry edited
through the `<RET>' command is marked fuzzy, as a way to ensure some
kind of double check, later.  In this case, the usual paradigm is that
an entry becomes fuzzy (if not already) whenever the translator
modifies it.  If she is satisfied with the translation, she then uses
`<TAB>' to pick another entry to work on, clearing the fuzzy attribute
on the same blow.  If she is not satisfied yet, she merely uses `<SPC>'
to chase another entry, leaving the entry fuzzy.

   The translator may also use the `<DEL>' command
(`po-fade-out-entry') over any translated entry to mark it as being
fuzzy, when she wants to easily leave a trace she wants to later return
working at this entry.

   Also, when time comes to quit working on a PO file buffer with the
`q' command, the translator is asked for confirmation, if fuzzy string
still exists.


File: gettext.info,  Node: Untranslated Entries,  Next: Obsolete Entries,  Prev: Fuzzy Entries,  Up: Updating

Untranslated Entries
====================

   When `xgettext' originally creates a PO file, unless told otherwise,
it initializes the `msgid' field with the untranslated string, and
leaves the `msgstr' string to be empty.  Such entries, having an empty
translation, are said to be "untranslated" entries.  Later, when the
programmer slightly modifies some string right in the program, this
change is later reflected in the PO file by the appearance of a new
untranslated entry for the modified string.

   The usual commands moving from entry to entry consider untranslated
entries on the same level as active entries.  Untranslated entries are
easily recognizable by the fact they end with `msgstr ""'.

   The work of the translator might be (quite naively) seen as the
process of seeking for an untranslated entry, editing a translation for
it, and repeating these actions until no untranslated entries remain.
Some commands are more specifically related to untranslated entry
processing.

`u'
     Find the next untranslated entry.

`M-u'
     Find the previous untranslated entry.

`k'
     Turn the current entry into an untranslated one.

   The commands `u' (`po-next-untranslated-entry') and `M-u'
(`po-previous-untransted-entry') move forwards or backwards, chasing
for an untranslated entry.  If none is found, the search is extended
and wraps around in the PO file buffer.

   An entry can be turned back into an untranslated entry by merely
emptying its translation, using the command `k' (`po-kill-msgstr').
*Note Modifying Translations::.

   Also, when time comes to quit working on a PO file buffer with the
`q' command, the translator is asked for confirmation, if some
untranslated string still exists.

