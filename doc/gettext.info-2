This is gettext.info, produced by makeinfo version 4.0 from
gettext.texi.

INFO-DIR-SECTION GNU Gettext Utilities
START-INFO-DIR-ENTRY
* Gettext: (gettext).                           GNU gettext utilities.
* gettextize: (gettext)gettextize Invocation.   Prepare a package for gettext.
* msgfmt: (gettext)msgfmt Invocation.           Make MO files out of PO files.
* msgmerge: (gettext)msgmerge Invocation.       Update two PO files into one.
* xgettext: (gettext)xgettext Invocation.       Extract strings into a PO file.
END-INFO-DIR-ENTRY

   This file provides documentation for GNU `gettext' utilities.  It
also serves as a reference for the free Translation Project.

   Copyright (C) 1995, 1996, 1997, 1998, 2001 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gettext.info,  Node: Main PO Commands,  Next: Entry Positioning,  Prev: PO Files,  Up: Basics

Main PO mode Commands
=====================

   After setting up Emacs with something similar to the lines in *Note
Installation::, PO mode is activated for a window when Emacs finds a PO
file in that window.  This puts the window read-only and establishes a
po-mode-map, which is a genuine Emacs mode, in a way that is not derived
from text mode in any way.  Functions found on `po-mode-hook', if any,
will be executed.

   When PO mode is active in a window, the letters `PO' appear in the
mode line for that window.  The mode line also displays how many
entries of each kind are held in the PO file.  For example, the string
`132t+3f+10u+2o' would tell the translator that the PO mode contains
132 translated entries (*note Translated Entries::, 3 fuzzy entries
(*note Fuzzy Entries::), 10 untranslated entries (*note Untranslated
Entries::) and 2 obsolete entries (*note Obsolete Entries::).
Zero-coefficients items are not shown.  So, in this example, if the
fuzzy entries were unfuzzied, the untranslated entries were translated
and the obsolete entries were deleted, the mode line would merely
display `145t' for the counters.

   The main PO commands are those which do not fit into the other
categories of subsequent sections.  These allow for quitting PO mode or
for managing windows in special ways.

`_'
     Undo last modification to the PO file (`po-undo').

`Q'
     Quit processing and save the PO file (`po-quit').

`q'
     Quit processing, possibly after confirmation
     (`po-confirm-and-quit').

`0'
     Temporary leave the PO file window (`po-other-window').

`?'
`h'
     Show help about PO mode (`po-help').

`='
     Give some PO file statistics (`po-statistics').

`V'
     Batch validate the format of the whole PO file (`po-validate').

   The command `_' (`po-undo') interfaces to the Emacs _undo_ facility.
*Note Undoing Changes: (emacs)Undo.  Each time `U' is typed,
modifications which the translator did to the PO file are undone a
little more.  For the purpose of undoing, each PO mode command is
atomic.  This is especially true for the `<RET>' command: the whole
edition made by using a single use of this command is undone at once,
even if the edition itself implied several actions.  However, while in
the editing window, one can undo the edition work quite parsimoniously.

   The commands `Q' (`po-quit') and `q' (`po-confirm-and-quit') are
used when the translator is done with the PO file.  The former is a bit
less verbose than the latter.  If the file has been modified, it is
saved to disk first.  In both cases, and prior to all this, the
commands check if some untranslated message remains in the PO file and,
if yes, the translator is asked if she really wants to leave off
working with this PO file.  This is the preferred way of getting rid of
an Emacs PO file buffer.  Merely killing it through the usual command
`C-x k' (`kill-buffer') is not the tidiest way to proceed.

   The command `0' (`po-other-window') is another, softer way, to leave
PO mode, temporarily.  It just moves the cursor to some other Emacs
window, and pops one if necessary.  For example, if the translator just
got PO mode to show some source context in some other, she might
discover some apparent bug in the program source that needs correction.
This command allows the translator to change sex, become a programmer,
and have the cursor right into the window containing the program she
(or rather _he_) wants to modify.  By later getting the cursor back in
the PO file window, or by asking Emacs to edit this file once again, PO
mode is then recovered.

   The command `h' (`po-help') displays a summary of all available PO
mode commands.  The translator should then type any character to resume
normal PO mode operations.  The command `?' has the same effect as `h'.

   The command `=' (`po-statistics') computes the total number of
entries in the PO file, the ordinal of the current entry (counted from
1), the number of untranslated entries, the number of obsolete entries,
and displays all these numbers.

   The command `V' (`po-validate') launches `msgfmt' in checking and
verbose mode over the current PO file.  This command first offers to
save the current PO file on disk.  The `msgfmt' tool, from GNU
`gettext', has the purpose of creating a MO file out of a PO file, and
PO mode uses the features of this program for checking the overall
format of a PO file, as well as all individual entries.

   The program `msgfmt' runs asynchronously with Emacs, so the
translator regains control immediately while her PO file is being
studied.  Error output is collected in the Emacs `*compilation*' buffer,
displayed in another window.  The regular Emacs command `C-x`'
(`next-error'), as well as other usual compile commands, allow the
translator to reposition quickly to the offending parts of the PO file.
Once the cursor is on the line in error, the translator may decide on
any PO mode action which would help correcting the error.


File: gettext.info,  Node: Entry Positioning,  Next: Normalizing,  Prev: Main PO Commands,  Up: Basics

Entry Positioning
=================

   The cursor in a PO file window is almost always part of an entry.
The only exceptions are the special case when the cursor is after the
last entry in the file, or when the PO file is empty.  The entry where
the cursor is found to be is said to be the current entry.  Many PO
mode commands operate on the current entry, so moving the cursor does
more than allowing the translator to browse the PO file, this also
selects on which entry commands operate.

   Some PO mode commands alter the position of the cursor in a
specialized way.  A few of those special purpose positioning are
described here, the others are described in following sections (for a
complete list try `C-h m'):

`.'
     Redisplay the current entry (`po-current-entry').

`n'
     Select the entry after the current one (`po-next-entry').

`p'
     Select the entry before the current one (`po-previous-entry').

`<'
     Select the first entry in the PO file (`po-first-entry').

`>'
     Select the last entry in the PO file (`po-last-entry').

`m'
     Record the location of the current entry for later use
     (`po-push-location').

`r'
     Return to a previously saved entry location (`po-pop-location').

`x'
     Exchange the current entry location with the previously saved one
     (`po-exchange-location').

   Any Emacs command able to reposition the cursor may be used to
select the current entry in PO mode, including commands which move by
characters, lines, paragraphs, screens or pages, and search commands.
However, there is a kind of standard way to display the current entry
in PO mode, which usual Emacs commands moving the cursor do not
especially try to enforce.  The command `.' (`po-current-entry') has
the sole purpose of redisplaying the current entry properly, after the
current entry has been changed by means external to PO mode, or the
Emacs screen otherwise altered.

   It is yet to be decided if PO mode helps the translator, or otherwise
irritates her, by forcing a rigid window disposition while she is doing
her work.  We originally had quite precise ideas about how windows
should behave, but on the other hand, anyone used to Emacs is often
happy to keep full control.  Maybe a fixed window disposition might be
offered as a PO mode option that the translator might activate or
deactivate at will, so it could be offered on an experimental basis.
If nobody feels a real need for using it, or a compulsion for writing
it, we should drop this whole idea.  The incentive for doing it should
come from translators rather than programmers, as opinions from an
experienced translator are surely more worth to me than opinions from
programmers _thinking_ about how _others_ should do translation.

   The commands `n' (`po-next-entry') and `p' (`po-previous-entry')
move the cursor the entry following, or preceding, the current one.  If
`n' is given while the cursor is on the last entry of the PO file, or
if `p' is given while the cursor is on the first entry, no move is done.

   The commands `<' (`po-first-entry') and `>' (`po-last-entry') move
the cursor to the first entry, or last entry, of the PO file.  When the
cursor is located past the last entry in a PO file, most PO mode
commands will return an error saying `After last entry'.  Moreover, the
commands `<' and `>' have the special property of being able to work
even when the cursor is not into some PO file entry, and one may use
them for nicely correcting this situation.  But even these commands
will fail on a truly empty PO file.  There are development plans for
the PO mode for it to interactively fill an empty PO file from sources.
*Note Marking::.

   The translator may decide, before working at the translation of a
particular entry, that she needs to browse the remainder of the PO
file, maybe for finding the terminology or phraseology used in related
entries.  She can of course use the standard Emacs idioms for saving
the current cursor location in some register, and use that register for
getting back, or else, use the location ring.

   PO mode offers another approach, by which cursor locations may be
saved onto a special stack.  The command `m' (`po-push-location')
merely adds the location of current entry to the stack, pushing the
already saved locations under the new one.  The command `r'
(`po-pop-location') consumes the top stack element and repositions the
cursor to the entry associated with that top element.  This position is
then lost, for the next `r' will move the cursor to the previously
saved location, and so on until no locations remain on the stack.

   If the translator wants the position to be kept on the location
stack, maybe for taking a look at the entry associated with the top
element, then go elsewhere with the intent of getting back later, she
ought to use `m' immediately after `r'.

   The command `x' (`po-exchange-location') simultaneously repositions
the cursor to the entry associated with the top element of the stack of
saved locations, and replaces that top element with the location of the
current entry before the move.  Consequently, repeating the `x' command
toggles alternatively between two entries.  For achieving this, the
translator will position the cursor on the first entry, use `m', then
position to the second entry, and merely use `x' for making the switch.


File: gettext.info,  Node: Normalizing,  Prev: Entry Positioning,  Up: Basics

Normalizing Strings in Entries
==============================

   There are many different ways for encoding a particular string into a
PO file entry, because there are so many different ways to split and
quote multi-line strings, and even, to represent special characters by
backslahsed escaped sequences.  Some features of PO mode rely on the
ability for PO mode to scan an already existing PO file for a
particular string encoded into the `msgid' field of some entry.  Even
if PO mode has internally all the built-in machinery for implementing
this recognition easily, doing it fast is technically difficult.  To
facilitate a solution to this efficiency problem, we decided on a
canonical representation for strings.

   A conventional representation of strings in a PO file is currently
under discussion, and PO mode experiments with a canonical
representation.  Having both `xgettext' and PO mode converging towards
a uniform way of representing equivalent strings would be useful, as
the internal normalization needed by PO mode could be automatically
satisfied when using `xgettext' from GNU `gettext'.  An explicit PO
mode normalization should then be only necessary for PO files imported
from elsewhere, or for when the convention itself evolves.

   So, for achieving normalization of at least the strings of a given
PO file needing a canonical representation, the following PO mode
command is available:

`M-x po-normalize'
     Tidy the whole PO file by making entries more uniform.

   The special command `M-x po-normalize', which has no associated
keys, revises all entries, ensuring that strings of both original and
translated entries use uniform internal quoting in the PO file.  It
also removes any crumb after the last entry.  This command may be
useful for PO files freshly imported from elsewhere, or if we ever
improve on the canonical quoting format we use.  This canonical format
is not only meant for getting cleaner PO files, but also for greatly
speeding up `msgid' string lookup for some other PO mode commands.

   `M-x po-normalize' presently makes three passes over the entries.
The first implements heuristics for converting PO files for GNU
`gettext' 0.6 and earlier, in which `msgid' and `msgstr' fields were
using K&R style C string syntax for multi-line strings.  These
heuristics may fail for comments not related to obsolete entries and
ending with a backslash; they also depend on subsequent passes for
finalizing the proper commenting of continued lines for obsolete
entries.  This first pass might disappear once all oldish PO files
would have been adjusted.  The second and third pass normalize all
`msgid' and `msgstr' strings respectively.  They also clean out those
trailing backslashes used by XView's `msgfmt' for continued lines.

   Having such an explicit normalizing command allows for importing PO
files from other sources, but also eases the evolution of the current
convention, evolution driven mostly by aesthetic concerns, as of now.
It is easy to make suggested adjustments at a later time, as the
normalizing command and eventually, other GNU `gettext' tools should
greatly automate conformance.  A description of the canonical string
format is given below, for the particular benefit of those not having
Emacs handy, and who would nevertheless want to handcraft their PO
files in nice ways.

   Right now, in PO mode, strings are single line or multi-line.  A
string goes multi-line if and only if it has _embedded_ newlines, that
is, if it matches `[^\n]\n+[^\n]'.  So, we would have:

     msgstr "\n\nHello, world!\n\n\n"

   but, replacing the space by a newline, this becomes:

     msgstr ""
     "\n"
     "\n"
     "Hello,\n"
     "world!\n"
     "\n"
     "\n"

   We are deliberately using a caricatural example, here, to make the
point clearer.  Usually, multi-lines are not that bad looking.  It is
probable that we will implement the following suggestion.  We might
lump together all initial newlines into the empty string, and also all
newlines introducing empty lines (that is, for N > 1, the N-1'th last
newlines would go together on a separate string), so making the
previous example appear:

     msgstr "\n\n"
     "Hello,\n"
     "world!\n"
     "\n\n"

   There are a few yet undecided little points about string
normalization, to be documented in this manual, once these questions
settle.


File: gettext.info,  Node: Sources,  Next: Template,  Prev: Basics,  Up: Top

Preparing Program Sources
*************************

   For the programmer, changes to the C source code fall into three
categories.  First, you have to make the localization functions known
to all modules needing message translation.  Second, you should
properly trigger the operation of GNU `gettext' when the program
initializes, usually from the `main' function.  Last, you should
identify and especially mark all constant strings in your program
needing translation.

   Presuming that your set of programs, or package, has been adjusted
so all needed GNU `gettext' files are available, and your `Makefile'
files are adjusted (*note Maintainers::), each C module having
translated C strings should contain the line:

     #include <libintl.h>

   The remaining changes to your C sources are discussed in the further
sections of this chapter.

* Menu:

* Triggering::                  Triggering `gettext' Operations
* Mark Keywords::               How Marks Appear in Sources
* Marking::                     Marking Translatable Strings
* c-format::                    Telling something about the following string
* Special cases::               Special Cases of Translatable Strings


File: gettext.info,  Node: Triggering,  Next: Mark Keywords,  Prev: Sources,  Up: Sources

Triggering `gettext' Operations
===============================

   The initialization of locale data should be done with more or less
the same code in every program, as demonstrated below:

     int
     main (argc, argv)
          int argc;
          char argv;
     {
       ...
       setlocale (LC_ALL, "");
       bindtextdomain (PACKAGE, LOCALEDIR);
       textdomain (PACKAGE);
       ...
     }

   PACKAGE and LOCALEDIR should be provided either by `config.h' or by
the Makefile.  For now consult the `gettext' sources for more
information.

   The use of `LC_ALL' might not be appropriate for you.  `LC_ALL'
includes all locale categories and especially `LC_CTYPE'.  This later
category is responsible for determining character classes with the
`isalnum' etc. functions from `ctype.h' which could especially for
programs, which process some kind of input language, be wrong.  For
example this would mean that a source code using the c, (c-cedilla
character) is runnable in France but not in the U.S.

   Some systems also have problems with parsing numbers using the
`scanf' functions if an other but the `LC_ALL' locale is used.  The
standards say that additional formats but the one known in the `"C"'
locale might be recognized.  But some systems seem to reject numbers in
the `"C"' locale format.  In some situation, it might also be a problem
with the notation itself which makes it impossible to recognize whether
the number is in the `"C"' locale or the local format.  This can happen
if thousands separator characters are used.  Some locales define this
character accordfing to the national conventions to `'.'' which is the
same character used in the `"C"' locale to denote the decimal point.

   So it is sometimes necessary to replace the `LC_ALL' line in the
code above by a sequence of `setlocale' lines

     {
       ...
       setlocale (LC_CTYPE, "");
       setlocale (LC_MESSAGES, "");
       ...
     }

On all POSIX conformant systems the locale categories `LC_CTYPE',
`LC_COLLATE', `LC_MONETARY', `LC_NUMERIC', and `LC_TIME' are available.
On some modern systems there is also a locale `LC_MESSAGES' which is
called on some old, XPG2 compliant systems `LC_RESPONSES'.

   Note that changing the `LC_CTYPE' also affects the functions
declared in the `<ctype.h>' standard header.  If this is not desirable
in your application (for example in a compiler's parser), you can use a
set of substitute functions which hardwire the C locale, such as found
in the `<c-ctype.h>' and `<c-ctype.c>' files in the gettext source
distribution.

   It is also possible to switch the locale forth and back between the
environment dependent locale and the C locale, but this approach is
normally avoided because a `setlocale' call is expensive, because it is
tedious to determine the places where a locale switch is needed in a
large program's source, and because switching a locale is not
multithread-safe.


File: gettext.info,  Node: Mark Keywords,  Next: Marking,  Prev: Triggering,  Up: Sources

How Marks Appear in Sources
===========================

   All strings requiring translation should be marked in the C sources.
Marking is done in such a way that each translatable string appears to
be the sole argument of some function or preprocessor macro.  There are
only a few such possible functions or macros meant for translation, and
their names are said to be marking keywords.  The marking is attached
to strings themselves, rather than to what we do with them.  This
approach has more uses.  A blatant example is an error message produced
by formatting.  The format string needs translation, as well as some
strings inserted through some `%s' specification in the format, while
the result from `sprintf' may have so many different instances that it
is impractical to list them all in some `error_string_out()' routine,
say.

   This marking operation has two goals.  The first goal of marking is
for triggering the retrieval of the translation, at run time.  The
keyword are possibly resolved into a routine able to dynamically return
the proper translation, as far as possible or wanted, for the argument
string.  Most localizable strings are found in executable positions,
that is, attached to variables or given as parameters to functions.
But this is not universal usage, and some translatable strings appear
in structured initializations.  *Note Special cases::.

   The second goal of the marking operation is to help `xgettext' at
properly extracting all translatable strings when it scans a set of
program sources and produces PO file templates.

   The canonical keyword for marking translatable strings is `gettext',
it gave its name to the whole GNU `gettext' package.  For packages
making only light use of the `gettext' keyword, macro or function, it
is easily used _as is_.  However, for packages using the `gettext'
interface more heavily, it is usually more convenient to give the main
keyword a shorter, less obtrusive name.  Indeed, the keyword might
appear on a lot of strings all over the package, and programmers
usually do not want nor need their program sources to remind them
forcefully, all the time, that they are internationalized.  Further, a
long keyword has the disadvantage of using more horizontal space,
forcing more indentation work on sources for those trying to keep them
within 79 or 80 columns.

   Many packages use `_' (a simple underline) as a keyword, and write
`_("Translatable string")' instead of `gettext ("Translatable
string")'.  Further, the coding rule, from GNU standards, wanting that
there is a space between the keyword and the opening parenthesis is
relaxed, in practice, for this particular usage.  So, the textual
overhead per translatable string is reduced to only three characters:
the underline and the two parentheses.  However, even if GNU `gettext'
uses this convention internally, it does not offer it officially.  The
real, genuine keyword is truly `gettext' indeed.  It is fairly easy for
those wanting to use `_' instead of `gettext' to declare:

     #include <libintl.h>
     #define _(String) gettext (String)

instead of merely using `#include <libintl.h>'.

   Later on, the maintenance is relatively easy.  If, as a programmer,
you add or modify a string, you will have to ask yourself if the new or
altered string requires translation, and include it within `_()' if you
think it should be translated.  `"%s: %d"' is an example of string
_not_ requiring translation!


File: gettext.info,  Node: Marking,  Next: c-format,  Prev: Mark Keywords,  Up: Sources

Marking Translatable Strings
============================

   In PO mode, one set of features is meant more for the programmer than
for the translator, and allows him to interactively mark which strings,
in a set of program sources, are translatable, and which are not.  Even
if it is a fairly easy job for a programmer to find and mark such
strings by other means, using any editor of his choice, PO mode makes
this work more comfortable.  Further, this gives translators who feel a
little like programmers, or programmers who feel a little like
translators, a tool letting them work at marking translatable strings
in the program sources, while simultaneously producing a set of
translation in some language, for the package being internationalized.

   The set of program sources, targetted by the PO mode commands
describe here, should have an Emacs tags table constructed for your
project, prior to using these PO file commands.  This is easy to do.
In any shell window, change the directory to the root of your project,
then execute a command resembling:

     etags src/*.[hc] lib/*.[hc]

presuming here you want to process all `.h' and `.c' files from the
`src/' and `lib/' directories.  This command will explore all said
files and create a `TAGS' file in your root directory, somewhat
summarizing the contents using a special file format Emacs can
understand.

   For packages following the GNU coding standards, there is a make
goal `tags' or `TAGS' which constructs the tag files in all directories
and for all files containing source code.

   Once your `TAGS' file is ready, the following commands assist the
programmer at marking translatable strings in his set of sources.  But
these commands are necessarily driven from within a PO file window, and
it is likely that you do not even have such a PO file yet.  This is not
a problem at all, as you may safely open a new, empty PO file, mainly
for using these commands.  This empty PO file will slowly fill in while
you mark strings as translatable in your program sources.

`,'
     Search through program sources for a string which looks like a
     candidate for translation (`po-tags-search').

`M-,'
     Mark the last string found with `_()' (`po-mark-translatable').

`M-.'
     Mark the last string found with a keyword taken from a set of
     possible keywords.  This command with a prefix allows some
     management of these keywords (`po-select-mark-and-mark').

   The `,' (`po-tags-search') command searches for the next occurrence
of a string which looks like a possible candidate for translation, and
displays the program source in another Emacs window, positioned in such
a way that the string is near the top of this other window.  If the
string is too big to fit whole in this window, it is positioned so only
its end is shown.  In any case, the cursor is left in the PO file
window.  If the shown string would be better presented differently in
different native languages, you may mark it using `M-,' or `M-.'.
Otherwise, you might rather ignore it and skip to the next string by
merely repeating the `,' command.

   A string is a good candidate for translation if it contains a
sequence of three or more letters.  A string containing at most two
letters in a row will be considered as a candidate if it has more
letters than non-letters.  The command disregards strings containing no
letters, or isolated letters only.  It also disregards strings within
comments, or strings already marked with some keyword PO mode knows
(see below).

   If you have never told Emacs about some `TAGS' file to use, the
command will request that you specify one from the minibuffer, the
first time you use the command.  You may later change your `TAGS' file
by using the regular Emacs command `M-x visit-tags-table', which will
ask you to name the precise `TAGS' file you want to use.  *Note Tag
Tables: (emacs)Tags.

   Each time you use the `,' command, the search resumes from where it
was left by the previous search, and goes through all program sources,
obeying the `TAGS' file, until all sources have been processed.
However, by giving a prefix argument to the command (`C-u ,'), you may
request that the search be restarted all over again from the first
program source; but in this case, strings that you recently marked as
translatable will be automatically skipped.

   Using this `,' command does not prevent using of other regular Emacs
tags commands.  For example, regular `tags-search' or
`tags-query-replace' commands may be used without disrupting the
independent `,' search sequence.  However, as implemented, the
_initial_ `,' command (or the `,' command is used with a prefix) might
also reinitialize the regular Emacs tags searching to the first tags
file, this reinitialization might be considered spurious.

   The `M-,' (`po-mark-translatable') command will mark the recently
found string with the `_' keyword.  The `M-.'
(`po-select-mark-and-mark') command will request that you type one
keyword from the minibuffer and use that keyword for marking the
string.  Both commands will automatically create a new PO file
untranslated entry for the string being marked, and make it the current
entry (making it easy for you to immediately proceed to its
translation, if you feel like doing it right away).  It is possible
that the modifications made to the program source by `M-,' or `M-.'
render some source line longer than 80 columns, forcing you to break
and re-indent this line differently.  You may use the `O' command from
PO mode, or any other window changing command from Emacs, to break out
into the program source window, and do any needed adjustments.  You
will have to use some regular Emacs command to return the cursor to the
PO file window, if you want command `,' for the next string, say.

   The `M-.' command has a few built-in speedups, so you do not have to
explicitly type all keywords all the time.  The first such speedup is
that you are presented with a _preferred_ keyword, which you may accept
by merely typing `<RET>' at the prompt.  The second speedup is that you
may type any non-ambiguous prefix of the keyword you really mean, and
the command will complete it automatically for you.  This also means
that PO mode has to _know_ all your possible keywords, and that it will
not accept mistyped keywords.

   If you reply `?' to the keyword request, the command gives a list of
all known keywords, from which you may choose.  When the command is
prefixed by an argument (`C-u M-.'), it inhibits updating any program
source or PO file buffer, and does some simple keyword management
instead.  In this case, the command asks for a keyword, written in
full, which becomes a new allowed keyword for later `M-.' commands.
Moreover, this new keyword automatically becomes the _preferred_
keyword for later commands.  By typing an already known keyword in
response to `C-u M-.', one merely changes the _preferred_ keyword and
does nothing more.

   All keywords known for `M-.' are recognized by the `,' command when
scanning for strings, and strings already marked by any of those known
keywords are automatically skipped.  If many PO files are opened
simultaneously, each one has its own independent set of known keywords.
There is no provision in PO mode, currently, for deleting a known
keyword, you have to quit the file (maybe using `q') and reopen it
afresh.  When a PO file is newly brought up in an Emacs window, only
`gettext' and `_' are known as keywords, and `gettext' is preferred for
the `M-.' command.  In fact, this is not useful to prefer `_', as this
one is already built in the `M-,' command.


File: gettext.info,  Node: c-format,  Next: Special cases,  Prev: Marking,  Up: Sources

Special Comments preceding Keywords
===================================

   In C programs strings are often used within calls of functions from
the `printf' family.  The special thing about these format strings is
that they can contain format specifiers introduced with `%'.  Assume we
have the code

     printf (gettext ("String `%s' has %d characters\n"), s, strlen (s));

A possible German translation for the above string might be:

     "%d Zeichen lang ist die Zeichenkette `%s'"

   A C programmer, even if he cannot speak German, will recognize that
there is something wrong here.  The order of the two format specifiers
is changed but of course the arguments in the `printf' don't have.
This will most probably lead to problems because now the length of the
string is regarded as the address.

   To prevent errors at runtime caused by translations the `msgfmt'
tool can check statically whether the arguments in the original and the
translation string match in type and number.  If this is not the case a
warning will be given and the error cannot causes problems at runtime.

If the word order in the above German translation would be correct one
would have to write

     "%2$d Zeichen lang ist die Zeichenkette `%1$s'"

The routines in `msgfmt' know about this special notation.

   Because not all strings in a program must be format strings it is not
useful for `msgfmt' to test all the strings in the `.po' file.  This
might cause problems because the string might contain what looks like a
format specifier, but the string is not used in `printf'.

   Therefore the `xgettext' adds a special tag to those messages it
thinks might be a format string.  There is no absolute rule for this,
only a heuristic.  In the `.po' file the entry is marked using the
`c-format' flag in the `#,' comment line (*note PO Files::).

   The careful reader now might say that this again can cause problems.
The heuristic might guess it wrong.  This is true and therefore
`xgettext' knows about special kind of comment which lets the
programmer take over the decision.  If in the same line or the
immediately preceding line of the `gettext' keyword the `xgettext'
program find a comment containing the words `xgettext:c-format' it will
mark the string in any case with the `c-format' flag.  This kind of
comment should be used when `xgettext' does not recognize the string as
a format string but is really is one and it should be tested.  Please
note that when the comment is in the same line of the `gettext'
keyword, it must be before the string to be translated.

   This situation happens quite often.  The `printf' function is often
called with strings which do not contain a format specifier.  Of course
one would normally use `fputs' but it does happen.  In this case
`xgettext' does not recognize this as a format string but what happens
if the translation introduces a valid format specifier?  The `printf'
function will try to access one of the parameter but none exists
because the original code does not refer to any parameter.

   `xgettext' of course could make a wrong decision the other way
round, i.e. a string marked as a format string actually is not a format
string.  In this case the `msgfmt' might give too many warnings and
would prevent translating the `.po' file.  The method to prevent this
wrong decision is similar to the one used above, only the comment to
use must contain the string `xgettext:no-c-format'.

   If a string is marked with `c-format' and this is not correct the
user can find out who is responsible for the decision.  See *Note
xgettext Invocation:: to see how the `--debug' option can be used for
solving this problem.


File: gettext.info,  Node: Special cases,  Prev: c-format,  Up: Sources

Special Cases of Translatable Strings
=====================================

   The attentive reader might now point out that it is not always
possible to mark translatable string with `gettext' or something like
this.  Consider the following case:

     {
       static const char *messages[] = {
         "some very meaningful message",
         "and another one"
       };
       const char *string;
       ...
       string
         = index > 1 ? "a default message" : messages[index];
     
       fputs (string);
       ...
     }

   While it is no problem to mark the string `"a default message"' it
is not possible to mark the string initializers for `messages'.  What
is to be done?  We have to fulfill two tasks.  First we have to mark the
strings so that the `xgettext' program (*note xgettext Invocation::)
can find them, and second we have to translate the string at runtime
before printing them.

   The first task can be fulfilled by creating a new keyword, which
names a no-op.  For the second we have to mark all access points to a
string from the array.  So one solution can look like this:

     #define gettext_noop(String) (String)
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message"),
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext ("a default message") : gettext (messages[index]);
     
       fputs (string);
       ...
     }

   Please convince yourself that the string which is written by `fputs'
is translated in any case.  How to get `xgettext' know the additional
keyword `gettext_noop' is explained in *Note xgettext Invocation::.

   The above is of course not the only solution.  You could also come
along with the following one:

     #define gettext_noop(String) (String)
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message",
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext_noop ("a default message") : messages[index];
     
       fputs (gettext (string));
       ...
     }

   But this has some drawbacks.  First the programmer has to take care
that he uses `gettext_noop' for the string `"a default message"'.  A
use of `gettext' could have in rare cases unpredictable results.  The
second reason is found in the internals of the GNU `gettext' Library
which will make this solution less efficient.

   One advantage is that you need not make control flow analysis to make
sure the output is really translated in any case.  But this analysis is
generally not very difficult.  If it should be in any situation you can
use this second method in this situation.


File: gettext.info,  Node: Template,  Next: Creating,  Prev: Sources,  Up: Top

Making the PO Template File
***************************

   After preparing the sources, the programmer creates a PO template
file.  This section explains how to use `xgettext' for this purpose.

* Menu:

* xgettext Invocation::         Invoking the `xgettext' Program


File: gettext.info,  Node: xgettext Invocation,  Prev: Template,  Up: Template

Invoking the `xgettext' Program
===============================

     xgettext [OPTION] [INPUTFILE] ...

   The `xgettext' program extracts translatable strings from given
input files.

Input file location
-------------------

`INPUTFILE ...'
     Input files.

`-f FILE'
`--files-from=FILE'
     Read the names of the input files from FILE instead of getting
     them from the command line.

`-D DIRECTORY'
`--directory=DIRECTORY'
     Add DIRECTORY to the list of directories.  Source files are
     searched relative to this list of directories.  The resulting `.po'
     file will be written relative to the current directory, though.

   If INPUTFILE is `-', standard input is read.

Output file location
--------------------

`-d NAME'
`--default-domain=NAME'
     Use `NAME.po' for output (instead of `messages.po').

`-o FILE'
`--output=FILE'
     Write output to specified file (instead of `NAME.po' or
     `messages.po').

`-p DIR'
`--output-dir=DIR'
     Output files will be placed in directory DIR.

   If the output FILE is `-' or `/dev/stdout', the output is written to
standard output.

Choice of input file language
-----------------------------

`-L NAME'
`--language=NAME'
     Specifies the language of the input files.  The supported languages
     are `C', `C++', `ObjectiveC', `PO', `Java', `YCP'.

`-C'
`--c++'
     This is a shorthand for `--language=C++'.

   By default the language is guessed depending on the input file name
extension.

Operation mode
--------------

`-j'
`--join-existing'
     Join messages with existing file.

`-x FILE'
`--exclude-file=FILE'
     Entries from FILE are not extracted.  FILE should be a PO or POT
     file.

`-c [TAG]'
`--add-comments[=TAG]'
     Place comment block with TAG (or those preceding keyword lines) in
     output file.

Language=C/C++ specific options
-------------------------------

`-a'
`--extract-all'
     Extract all strings.

`-k KEYWORDSPEC'
`--keyword[=KEYWORDSPEC]'
     Additional keyword to be looked for (without KEYWORDSPEC means not
     to use default keywords).

     If KEYWORDSPEC is a C identifer ID, `xgettext' looks for strings
     in the first argument of each call to the function or macro ID.
     If KEYWORDSPEC is of the form `ID:ARGNUM', `xgettext' looks for
     strings in the ARGNUMth argument of the call.  If KEYWORDSPEC is
     of the form `ID:ARGNUM1,ARGNUM2', `xgettext' looks for strings in
     the ARGNUM1st argument and in the ARGNUM2nd argument of the call,
     and treats them as singular/plural variants for a message with
     plural handling.

     The default keyword specifications, which are always looked for if
     not explicitly disabled, are `gettext', `dgettext:2',
     `dcgettext:2', `ngettext:1,2', `dngettext:2,3', `dcngettext:2,3',
     and `gettext_noop'.

`-T'
`--trigraphs'
     Understand ANSI C trigraphs for input.

`--debug'
     Use the flags `c-format' and `possible-c-format' to show who was
     responsible for marking a message as a format string.  The latter
     form is used if the `xgettext' program decided, the format form is
     used if the programmer prescribed it.

     By default only the `c-format' form is used.  The translator should
     not have to care about these details.

   This implementation of `xgettext' is able to process a few awkward
cases, like strings in preprocessor macros, ANSI concatenation of
adjacent strings, and escaped end of lines for continued strings.

Output details
--------------

`--force-po'
     Always write an output file even if no message is defined.

`-i'
`--indent'
     Write the .po file using indented style.

`--no-location'
     Do not write `#: FILENAME:LINE' lines.

`-n'
`--add-location'
     Generate `#: FILENAME:LINE' lines (default).

`--strict'
     Write out a strict Uniforum conforming PO file.  Note that this
     Uniforum format should be avoided because it doesn't support the
     GNU extensions.

`-w NUMBER'
`--width=NUMBER'
     Set the output page width.  Long strings in the output files will
     be split across multiple lines in order to ensure that each line's
     width (= number of screen columns) is less or equal to the given
     NUMBER.

`-s'
`--sort-output'
     Generate sorted output.  Note that using this option makes it much
     harder for the translator to understand each message's context.

`-F'
`--sort-by-file'
     Sort output by file location.

`--omit-header'
     Don't write header with `msgid ""' entry.

     This is useful for testing purposes because it eliminates a source
     of variance for generated `.gmo' files.  With `--omit-header', two
     invocations of `xgettext' on the same files with the same options
     at different times are guaranteed to produce the same results.

`--foreign-user'
     Omit FSF copyright in output.  This can be useful for translators
     outside the GNU project.

`-m [STRING]'
`--msgstr-prefix[=STRING]'
     Use STRING (or "" if not specified) as prefix for msgstr entries.

`-M [STRING]'
`--msgstr-suffix[=STRING]'
     Use STRING (or "" if not specified) as suffix for msgstr entries.

Informative output
------------------

`-h'
`--help'
     Display this help and exit.

`-V'
`--version'
     Output version information and exit.


File: gettext.info,  Node: Creating,  Next: Updating,  Prev: Template,  Up: Top

Creating a New PO File
**********************

   When starting a new translation, the translator creates a file called
`LANG.po', as a copy of the `PACKAGE.pot' template file with
modifications in the initial comments (at the beginning of the file)
and in the header entry (the first entry, near the beginning of the
file).

   The easiest way to do so is by use of the `msginit' program.  For
example:

     $ cd PACKAGE-VERSION
     $ cd po
     $ msginit --verbose

   The alternative way is to do the copy and modifications by hand.  To
do so, the translator copies `PACKAGE.pot' to `LANG.po'.  Then she
modifies the initial comments and the header entry of this file.

* Menu:

* msginit Invocation::          Invoking the `msginit' Program
* Header Entry::                Filling in the Header Entry


File: gettext.info,  Node: msginit Invocation,  Next: Header Entry,  Prev: Creating,  Up: Creating

Invoking the `msginit' Program
==============================

     msginit [OPTION]

   The `msginit' program creates a new PO file, initializing the meta
information with values from the user's environment.

Input file location
-------------------

`-i INPUTFILE'
`--input=INPUTFILE'
     Input POT file.

   If no INPUTFILE is given, the current directory is searched for the
POT file.  If it is `-', standard input is read.

Output file location
--------------------

`-o FILE'
`--output-file=FILE'
     Write output to specified PO file.

   If no output file is given, it depends on the `--locale' option or
the user's locale setting.  If it is `-', the results are written to
standard output.

Output details
--------------

`-l LL_CC'
`--locale=LL_CC'
     Set target locale.  LL should be a language code, and CC should be
     a country code.  The command `locale -a' can be used to output a
     list of all installed locales.  The default is the user's locale
     setting.

`--no-translator'
     Declares that the PO file will not have a human translator and is
     instead automatically generated.

`-w NUMBER'
`--width=NUMBER'
     Set the output page width.  Long strings in the output files will
     be split across multiple lines in order to ensure that each line's
     width (= number of screen columns) is less or equal to the given
     NUMBER.

Informative output
------------------

`-h'
`--help'
     Display this help and exit.

`-V'
`--version'
     Output version information and exit.

