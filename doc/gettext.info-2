This is gettext.info, produced by makeinfo version 4.0 from
gettext.texi.

INFO-DIR-SECTION GNU Gettext Utilities
START-INFO-DIR-ENTRY
* Gettext: (gettext).                           GNU gettext utilities.
* gettextize: (gettext)gettextize Invocation.   Prepare a package for gettext.
* msgfmt: (gettext)msgfmt Invocation.           Make MO files out of PO files.
* msgmerge: (gettext)msgmerge Invocation.       Update two PO files into one.
* xgettext: (gettext)xgettext Invocation.       Extract strings into a PO file.
END-INFO-DIR-ENTRY

   This file provides documentation for GNU `gettext' utilities.  It
also serves as a reference for the free Translation Project.

   Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gettext.info,  Node: Main PO Commands,  Next: Entry Positioning,  Prev: PO Files,  Up: Basics

Main PO mode Commands
=====================

   After setting up Emacs with something similar to the lines in *Note
Installation::, PO mode is activated for a window when Emacs finds a PO
file in that window.  This puts the window read-only and establishes a
po-mode-map, which is a genuine Emacs mode, in a way that is not derived
from text mode in any way.  Functions found on `po-mode-hook', if any,
will be executed.

   When PO mode is active in a window, the letters `PO' appear in the
mode line for that window.  The mode line also displays how many
entries of each kind are held in the PO file.  For example, the string
`132t+3f+10u+2o' would tell the translator that the PO mode contains
132 translated entries (*note Translated Entries::, 3 fuzzy entries
(*note Fuzzy Entries::), 10 untranslated entries (*note Untranslated
Entries::) and 2 obsolete entries (*note Obsolete Entries::).
Zero-coefficients items are not shown.  So, in this example, if the
fuzzy entries were unfuzzied, the untranslated entries were translated
and the obsolete entries were deleted, the mode line would merely
display `145t' for the counters.

   The main PO commands are those which do not fit into the other
categories of subsequent sections.  These allow for quitting PO mode or
for managing windows in special ways.

`_'
     Undo last modification to the PO file (`po-undo').

`Q'
     Quit processing and save the PO file (`po-quit').

`q'
     Quit processing, possibly after confirmation
     (`po-confirm-and-quit').

`0'
     Temporary leave the PO file window (`po-other-window').

`?'
`h'
     Show help about PO mode (`po-help').

`='
     Give some PO file statistics (`po-statistics').

`V'
     Batch validate the format of the whole PO file (`po-validate').

   The command `_' (`po-undo') interfaces to the Emacs _undo_ facility.
*Note Undoing Changes: (emacs)Undo.  Each time `U' is typed,
modifications which the translator did to the PO file are undone a
little more.  For the purpose of undoing, each PO mode command is
atomic.  This is especially true for the `<RET>' command: the whole
edition made by using a single use of this command is undone at once,
even if the edition itself implied several actions.  However, while in
the editing window, one can undo the edition work quite parsimoniously.

   The commands `Q' (`po-quit') and `q' (`po-confirm-and-quit') are
used when the translator is done with the PO file.  The former is a bit
less verbose than the latter.  If the file has been modified, it is
saved to disk first.  In both cases, and prior to all this, the
commands check if any untranslated messages remain in the PO file and,
if so, the translator is asked if she really wants to leave off working
with this PO file.  This is the preferred way of getting rid of an
Emacs PO file buffer.  Merely killing it through the usual command
`C-x k' (`kill-buffer') is not the tidiest way to proceed.

   The command `0' (`po-other-window') is another, softer way, to leave
PO mode, temporarily.  It just moves the cursor to some other Emacs
window, and pops one if necessary.  For example, if the translator just
got PO mode to show some source context in some other, she might
discover some apparent bug in the program source that needs correction.
This command allows the translator to change sex, become a programmer,
and have the cursor right into the window containing the program she
(or rather _he_) wants to modify.  By later getting the cursor back in
the PO file window, or by asking Emacs to edit this file once again, PO
mode is then recovered.

   The command `h' (`po-help') displays a summary of all available PO
mode commands.  The translator should then type any character to resume
normal PO mode operations.  The command `?' has the same effect as `h'.

   The command `=' (`po-statistics') computes the total number of
entries in the PO file, the ordinal of the current entry (counted from
1), the number of untranslated entries, the number of obsolete entries,
and displays all these numbers.

   The command `V' (`po-validate') launches `msgfmt' in checking and
verbose mode over the current PO file.  This command first offers to
save the current PO file on disk.  The `msgfmt' tool, from GNU
`gettext', has the purpose of creating a MO file out of a PO file, and
PO mode uses the features of this program for checking the overall
format of a PO file, as well as all individual entries.

   The program `msgfmt' runs asynchronously with Emacs, so the
translator regains control immediately while her PO file is being
studied.  Error output is collected in the Emacs `*compilation*' buffer,
displayed in another window.  The regular Emacs command `C-x`'
(`next-error'), as well as other usual compile commands, allow the
translator to reposition quickly to the offending parts of the PO file.
Once the cursor is on the line in error, the translator may decide on
any PO mode action which would help correcting the error.


File: gettext.info,  Node: Entry Positioning,  Next: Normalizing,  Prev: Main PO Commands,  Up: Basics

Entry Positioning
=================

   The cursor in a PO file window is almost always part of an entry.
The only exceptions are the special case when the cursor is after the
last entry in the file, or when the PO file is empty.  The entry where
the cursor is found to be is said to be the current entry.  Many PO
mode commands operate on the current entry, so moving the cursor does
more than allowing the translator to browse the PO file, this also
selects on which entry commands operate.

   Some PO mode commands alter the position of the cursor in a
specialized way.  A few of those special purpose positioning are
described here, the others are described in following sections (for a
complete list try `C-h m'):

`.'
     Redisplay the current entry (`po-current-entry').

`n'
     Select the entry after the current one (`po-next-entry').

`p'
     Select the entry before the current one (`po-previous-entry').

`<'
     Select the first entry in the PO file (`po-first-entry').

`>'
     Select the last entry in the PO file (`po-last-entry').

`m'
     Record the location of the current entry for later use
     (`po-push-location').

`r'
     Return to a previously saved entry location (`po-pop-location').

`x'
     Exchange the current entry location with the previously saved one
     (`po-exchange-location').

   Any Emacs command able to reposition the cursor may be used to
select the current entry in PO mode, including commands which move by
characters, lines, paragraphs, screens or pages, and search commands.
However, there is a kind of standard way to display the current entry
in PO mode, which usual Emacs commands moving the cursor do not
especially try to enforce.  The command `.' (`po-current-entry') has
the sole purpose of redisplaying the current entry properly, after the
current entry has been changed by means external to PO mode, or the
Emacs screen otherwise altered.

   It is yet to be decided if PO mode helps the translator, or otherwise
irritates her, by forcing a rigid window disposition while she is doing
her work.  We originally had quite precise ideas about how windows
should behave, but on the other hand, anyone used to Emacs is often
happy to keep full control.  Maybe a fixed window disposition might be
offered as a PO mode option that the translator might activate or
deactivate at will, so it could be offered on an experimental basis.
If nobody feels a real need for using it, or a compulsion for writing
it, we should drop this whole idea.  The incentive for doing it should
come from translators rather than programmers, as opinions from an
experienced translator are surely more worth to me than opinions from
programmers _thinking_ about how _others_ should do translation.

   The commands `n' (`po-next-entry') and `p' (`po-previous-entry')
move the cursor the entry following, or preceding, the current one.  If
`n' is given while the cursor is on the last entry of the PO file, or
if `p' is given while the cursor is on the first entry, no move is done.

   The commands `<' (`po-first-entry') and `>' (`po-last-entry') move
the cursor to the first entry, or last entry, of the PO file.  When the
cursor is located past the last entry in a PO file, most PO mode
commands will return an error saying `After last entry'.  Moreover, the
commands `<' and `>' have the special property of being able to work
even when the cursor is not into some PO file entry, and one may use
them for nicely correcting this situation.  But even these commands
will fail on a truly empty PO file.  There are development plans for
the PO mode for it to interactively fill an empty PO file from sources.
*Note Marking::.

   The translator may decide, before working at the translation of a
particular entry, that she needs to browse the remainder of the PO
file, maybe for finding the terminology or phraseology used in related
entries.  She can of course use the standard Emacs idioms for saving
the current cursor location in some register, and use that register for
getting back, or else, use the location ring.

   PO mode offers another approach, by which cursor locations may be
saved onto a special stack.  The command `m' (`po-push-location')
merely adds the location of current entry to the stack, pushing the
already saved locations under the new one.  The command `r'
(`po-pop-location') consumes the top stack element and repositions the
cursor to the entry associated with that top element.  This position is
then lost, for the next `r' will move the cursor to the previously
saved location, and so on until no locations remain on the stack.

   If the translator wants the position to be kept on the location
stack, maybe for taking a look at the entry associated with the top
element, then go elsewhere with the intent of getting back later, she
ought to use `m' immediately after `r'.

   The command `x' (`po-exchange-location') simultaneously repositions
the cursor to the entry associated with the top element of the stack of
saved locations, and replaces that top element with the location of the
current entry before the move.  Consequently, repeating the `x' command
toggles alternatively between two entries.  For achieving this, the
translator will position the cursor on the first entry, use `m', then
position to the second entry, and merely use `x' for making the switch.


File: gettext.info,  Node: Normalizing,  Prev: Entry Positioning,  Up: Basics

Normalizing Strings in Entries
==============================

   There are many different ways for encoding a particular string into a
PO file entry, because there are so many different ways to split and
quote multi-line strings, and even, to represent special characters by
backslashed escaped sequences.  Some features of PO mode rely on the
ability for PO mode to scan an already existing PO file for a
particular string encoded into the `msgid' field of some entry.  Even
if PO mode has internally all the built-in machinery for implementing
this recognition easily, doing it fast is technically difficult.  To
facilitate a solution to this efficiency problem, we decided on a
canonical representation for strings.

   A conventional representation of strings in a PO file is currently
under discussion, and PO mode experiments with a canonical
representation.  Having both `xgettext' and PO mode converging towards
a uniform way of representing equivalent strings would be useful, as
the internal normalization needed by PO mode could be automatically
satisfied when using `xgettext' from GNU `gettext'.  An explicit PO
mode normalization should then be only necessary for PO files imported
from elsewhere, or for when the convention itself evolves.

   So, for achieving normalization of at least the strings of a given
PO file needing a canonical representation, the following PO mode
command is available:

`M-x po-normalize'
     Tidy the whole PO file by making entries more uniform.

   The special command `M-x po-normalize', which has no associated
keys, revises all entries, ensuring that strings of both original and
translated entries use uniform internal quoting in the PO file.  It
also removes any crumb after the last entry.  This command may be
useful for PO files freshly imported from elsewhere, or if we ever
improve on the canonical quoting format we use.  This canonical format
is not only meant for getting cleaner PO files, but also for greatly
speeding up `msgid' string lookup for some other PO mode commands.

   `M-x po-normalize' presently makes three passes over the entries.
The first implements heuristics for converting PO files for GNU
`gettext' 0.6 and earlier, in which `msgid' and `msgstr' fields were
using K&R style C string syntax for multi-line strings.  These
heuristics may fail for comments not related to obsolete entries and
ending with a backslash; they also depend on subsequent passes for
finalizing the proper commenting of continued lines for obsolete
entries.  This first pass might disappear once all oldish PO files
would have been adjusted.  The second and third pass normalize all
`msgid' and `msgstr' strings respectively.  They also clean out those
trailing backslashes used by XView's `msgfmt' for continued lines.

   Having such an explicit normalizing command allows for importing PO
files from other sources, but also eases the evolution of the current
convention, evolution driven mostly by aesthetic concerns, as of now.
It is easy to make suggested adjustments at a later time, as the
normalizing command and eventually, other GNU `gettext' tools should
greatly automate conformance.  A description of the canonical string
format is given below, for the particular benefit of those not having
Emacs handy, and who would nevertheless want to handcraft their PO
files in nice ways.

   Right now, in PO mode, strings are single line or multi-line.  A
string goes multi-line if and only if it has _embedded_ newlines, that
is, if it matches `[^\n]\n+[^\n]'.  So, we would have:

     msgstr "\n\nHello, world!\n\n\n"

   but, replacing the space by a newline, this becomes:

     msgstr ""
     "\n"
     "\n"
     "Hello,\n"
     "world!\n"
     "\n"
     "\n"

   We are deliberately using a caricatural example, here, to make the
point clearer.  Usually, multi-lines are not that bad looking.  It is
probable that we will implement the following suggestion.  We might
lump together all initial newlines into the empty string, and also all
newlines introducing empty lines (that is, for N > 1, the N-1'th last
newlines would go together on a separate string), so making the
previous example appear:

     msgstr "\n\n"
     "Hello,\n"
     "world!\n"
     "\n\n"

   There are a few yet undecided little points about string
normalization, to be documented in this manual, once these questions
settle.


File: gettext.info,  Node: Sources,  Next: Template,  Prev: Basics,  Up: Top

Preparing Program Sources
*************************

   For the programmer, changes to the C source code fall into three
categories.  First, you have to make the localization functions known
to all modules needing message translation.  Second, you should
properly trigger the operation of GNU `gettext' when the program
initializes, usually from the `main' function.  Last, you should
identify and especially mark all constant strings in your program
needing translation.

   Presuming that your set of programs, or package, has been adjusted
so all needed GNU `gettext' files are available, and your `Makefile'
files are adjusted (*note Maintainers::), each C module having
translated C strings should contain the line:

     #include <libintl.h>

   The remaining changes to your C sources are discussed in the further
sections of this chapter.

* Menu:

* Triggering::                  Triggering `gettext' Operations
* Preparing Strings::           Preparing Translatable Strings
* Mark Keywords::               How Marks Appear in Sources
* Marking::                     Marking Translatable Strings
* c-format Flag::               Telling something about the following string
* Special cases::               Special Cases of Translatable Strings


File: gettext.info,  Node: Triggering,  Next: Preparing Strings,  Prev: Sources,  Up: Sources

Triggering `gettext' Operations
===============================

   The initialization of locale data should be done with more or less
the same code in every program, as demonstrated below:

     int
     main (argc, argv)
          int argc;
          char argv;
     {
       ...
       setlocale (LC_ALL, "");
       bindtextdomain (PACKAGE, LOCALEDIR);
       textdomain (PACKAGE);
       ...
     }

   PACKAGE and LOCALEDIR should be provided either by `config.h' or by
the Makefile.  For now consult the `gettext' or `hello' sources for
more information.

   The use of `LC_ALL' might not be appropriate for you.  `LC_ALL'
includes all locale categories and especially `LC_CTYPE'.  This later
category is responsible for determining character classes with the
`isalnum' etc. functions from `ctype.h' which could especially for
programs, which process some kind of input language, be wrong.  For
example this would mean that a source code using the c, (c-cedilla
character) is runnable in France but not in the U.S.

   Some systems also have problems with parsing numbers using the
`scanf' functions if an other but the `LC_ALL' locale is used.  The
standards say that additional formats but the one known in the `"C"'
locale might be recognized.  But some systems seem to reject numbers in
the `"C"' locale format.  In some situation, it might also be a problem
with the notation itself which makes it impossible to recognize whether
the number is in the `"C"' locale or the local format.  This can happen
if thousands separator characters are used.  Some locales define this
character according to the national conventions to `'.'' which is the
same character used in the `"C"' locale to denote the decimal point.

   So it is sometimes necessary to replace the `LC_ALL' line in the
code above by a sequence of `setlocale' lines

     {
       ...
       setlocale (LC_CTYPE, "");
       setlocale (LC_MESSAGES, "");
       ...
     }

On all POSIX conformant systems the locale categories `LC_CTYPE',
`LC_COLLATE', `LC_MONETARY', `LC_NUMERIC', and `LC_TIME' are available.
On some modern systems there is also a locale `LC_MESSAGES' which is
called on some old, XPG2 compliant systems `LC_RESPONSES'.

   Note that changing the `LC_CTYPE' also affects the functions
declared in the `<ctype.h>' standard header.  If this is not desirable
in your application (for example in a compiler's parser), you can use a
set of substitute functions which hardwire the C locale, such as found
in the `<c-ctype.h>' and `<c-ctype.c>' files in the gettext source
distribution.

   It is also possible to switch the locale forth and back between the
environment dependent locale and the C locale, but this approach is
normally avoided because a `setlocale' call is expensive, because it is
tedious to determine the places where a locale switch is needed in a
large program's source, and because switching a locale is not
multithread-safe.


File: gettext.info,  Node: Preparing Strings,  Next: Mark Keywords,  Prev: Triggering,  Up: Sources

Preparing Translatable Strings
==============================

   Before strings can be marked for translations, they sometimes need to
be adjusted. Usually preparing a string for translation is done right
before marking it, during the marking phase which is described in the
next sections. What you have to keep in mind while doing that is the
following.

   * Decent English style.

   * Entire sentences.

   * Split at paragraphs.

   * Use format strings instead of string concatenation.

Let's look at some examples of these guidelines.

   Translatable strings should be in good English style. If slang
language with abbreviations and shortcuts is used, often translators
will not understand the message and will produce very inappropriate
translations.

     "%s: is parameter\n"

This is nearly untranslatable: Is the displayed item _a_ parameter or
_the_ parameter?

     "No match"

The ambiguity in this message makes it ununderstandable: Is the program
attempting to set something on fire? Does it mean "The given object does
not match the template"? Does it mean "The template does not fit for any
of the objects"?

   In both cases, adding more words to the message will help both the
translator and the English speaking user.

   Translatable strings should be entire sentences. It is often not
possible to translate single verbs or adjectives in a substitutable way.

     printf ("File %s is %s protected", filename, rw ? "write" : "read");

Most translators will not look at the source and will thus only see the
string `"File %s is %s protected"', which is unintelligible. Change
this to

     printf (rw ? "File %s is write protected" : "File %s is read protected",
             filename);

This way the translator will not only understand the message, she will
also be able to find the appropriate grammatical construction. The
French translator for example translates "write protected" like
"protected against writing".

   Often sentences don't fit into a single line. If a sentence is output
using two subsequent `printf' statements, like this

     printf ("Locale charset \"%s\" is different from\n", lcharset);
     printf ("input file charset \"%s\".\n", fcharset);

the translator would have to translate two half sentences, but nothing
in the POT file would tell her that the two half sentences belong
together.  It is necessary to merge the two `printf' statements so that
the translator can handle the entire sentence at once and decide at
which place to insert a line break in the translation (if at all):

     printf ("Locale charset \"%s\" is different from\n\
     input file charset \"%s\".\n", lcharset, fcharset);

   You may now ask: how about two or more adjacent sentences? Like in
this case:

     puts ("Apollo 13 scenario: Stack overflow handling failed.");
     puts ("On the next stack overflow we will crash!!!");

Should these two statements merged into a single one? I would recommend
to merge them if the two sentences are related to each other, because
then it makes it easier for the translator to understand and translate
both. On the other hand, if one of the two messages is a stereotypic
one, occurring in other places as well, you will do a favour to the
translator by not merging the two. (Identical messages occurring in
several places are combined by xgettext, so the translator has to
handle them once only.)

   Translatable strings should be limited to one paragraph; don't let a
single message be longer than ten lines. The reason is that when the
translatable string changes, the translator is faced with the task of
updating the entire translated string. Maybe only a single word will
have changed in the English string, but the translator doesn't see that
(with the current translation tools), therefore she has to proofread
the entire message.

   Many GNU programs have a `--help' output that extends over several
screen pages. It is a courtesy towards the translators to split such a
message into several ones of five to ten lines each. While doing that,
you can also attempt to split the documented options into groups, such
as the input options, the output options, and the informative output
options. This will help every user to find the option he is looking for.

   Hardcoded string concatenation is sometimes used to construct English
strings:

     strcpy (s, "Replace ");
     strcat (s, object1);
     strcat (s, " with ");
     strcat (s, object2);
     strcat (s, "?");

In order to present to the translator only entire sentences, and also
because in some languages the translator might want to swap the order
of `object1' and `object2', it is necessary to change this to use a
format string:

     sprintf (s, "Replace %s with %s?", object1, object2);

   A similar case is compile time concatenation of strings. The ISO C 99
include file `<inttypes.h>' contains a macro `PRId64' that can be used
as a formatting directive for outputting an `int64_t' integer through
`printf'. It expands to a constant string, usually "d" or "ld" or "lld"
or something like this, depending on the platform.  Assume you have
code like

     printf ("The amount is %0" PRId64 "\n", number);

The `gettext' tools and library have special support for these
`<inttypes.h>' macros.  You can therefore simply write

     printf (gettext ("The amount is %0" PRId64 "\n"), number);

The PO file will contain the string "The amount is %0<PRId64>\n".  The
translators will provide a translation containing "%0<PRId64>" as well,
and at runtime the `gettext' function's result will contain the
appropriate constant string, "d" or "ld" or "lld".

   This works only for the predefined `<inttypes.h>' macros.  If you
have defined your own similar macros, let's say `MYPRId64', that are
not known to `xgettext', the solution for this problem is to change the
code like this:

     char buf1[100];
     sprintf (buf1, "%0" MYPRId64, number);
     printf (gettext ("The amount is %s\n"), buf1);

   This means, you put the platform dependent code in one statement,
and the internationalization code in a different statement. Note that a
buffer length of 100 is safe, because all available hardware integer
types are limited to 128 bits, and to print a 128 bit integer one needs
at most 54 characters, regardless whether in decimal, octal or
hexadecimal.

   All this applies to other programming languages as well. For
example, in Java, string contenation is very frequently used, because
it is a compiler built-in operator. Like in C, in Java, you would change

     System.out.println("Replace "+object1+" with "+object2+"?");

into a statement involving a format string:

     System.out.println(
         MessageFormat.format("Replace {0} with {1}?",
                              new Object[] { object1, object2 }));


File: gettext.info,  Node: Mark Keywords,  Next: Marking,  Prev: Preparing Strings,  Up: Sources

How Marks Appear in Sources
===========================

   All strings requiring translation should be marked in the C sources.
Marking is done in such a way that each translatable string appears to
be the sole argument of some function or preprocessor macro.  There are
only a few such possible functions or macros meant for translation, and
their names are said to be marking keywords.  The marking is attached
to strings themselves, rather than to what we do with them.  This
approach has more uses.  A blatant example is an error message produced
by formatting.  The format string needs translation, as well as some
strings inserted through some `%s' specification in the format, while
the result from `sprintf' may have so many different instances that it
is impractical to list them all in some `error_string_out()' routine,
say.

   This marking operation has two goals.  The first goal of marking is
for triggering the retrieval of the translation, at run time.  The
keyword are possibly resolved into a routine able to dynamically return
the proper translation, as far as possible or wanted, for the argument
string.  Most localizable strings are found in executable positions,
that is, attached to variables or given as parameters to functions.
But this is not universal usage, and some translatable strings appear
in structured initializations.  *Note Special cases::.

   The second goal of the marking operation is to help `xgettext' at
properly extracting all translatable strings when it scans a set of
program sources and produces PO file templates.

   The canonical keyword for marking translatable strings is `gettext',
it gave its name to the whole GNU `gettext' package.  For packages
making only light use of the `gettext' keyword, macro or function, it
is easily used _as is_.  However, for packages using the `gettext'
interface more heavily, it is usually more convenient to give the main
keyword a shorter, less obtrusive name.  Indeed, the keyword might
appear on a lot of strings all over the package, and programmers
usually do not want nor need their program sources to remind them
forcefully, all the time, that they are internationalized.  Further, a
long keyword has the disadvantage of using more horizontal space,
forcing more indentation work on sources for those trying to keep them
within 79 or 80 columns.

   Many packages use `_' (a simple underline) as a keyword, and write
`_("Translatable string")' instead of `gettext ("Translatable
string")'.  Further, the coding rule, from GNU standards, wanting that
there is a space between the keyword and the opening parenthesis is
relaxed, in practice, for this particular usage.  So, the textual
overhead per translatable string is reduced to only three characters:
the underline and the two parentheses.  However, even if GNU `gettext'
uses this convention internally, it does not offer it officially.  The
real, genuine keyword is truly `gettext' indeed.  It is fairly easy for
those wanting to use `_' instead of `gettext' to declare:

     #include <libintl.h>
     #define _(String) gettext (String)

instead of merely using `#include <libintl.h>'.

   Later on, the maintenance is relatively easy.  If, as a programmer,
you add or modify a string, you will have to ask yourself if the new or
altered string requires translation, and include it within `_()' if you
think it should be translated.  `"%s: %d"' is an example of string
_not_ requiring translation!


File: gettext.info,  Node: Marking,  Next: c-format Flag,  Prev: Mark Keywords,  Up: Sources

Marking Translatable Strings
============================

   In PO mode, one set of features is meant more for the programmer than
for the translator, and allows him to interactively mark which strings,
in a set of program sources, are translatable, and which are not.  Even
if it is a fairly easy job for a programmer to find and mark such
strings by other means, using any editor of his choice, PO mode makes
this work more comfortable.  Further, this gives translators who feel a
little like programmers, or programmers who feel a little like
translators, a tool letting them work at marking translatable strings
in the program sources, while simultaneously producing a set of
translation in some language, for the package being internationalized.

   The set of program sources, targetted by the PO mode commands
describe here, should have an Emacs tags table constructed for your
project, prior to using these PO file commands.  This is easy to do.
In any shell window, change the directory to the root of your project,
then execute a command resembling:

     etags src/*.[hc] lib/*.[hc]

presuming here you want to process all `.h' and `.c' files from the
`src/' and `lib/' directories.  This command will explore all said
files and create a `TAGS' file in your root directory, somewhat
summarizing the contents using a special file format Emacs can
understand.

   For packages following the GNU coding standards, there is a make
goal `tags' or `TAGS' which constructs the tag files in all directories
and for all files containing source code.

   Once your `TAGS' file is ready, the following commands assist the
programmer at marking translatable strings in his set of sources.  But
these commands are necessarily driven from within a PO file window, and
it is likely that you do not even have such a PO file yet.  This is not
a problem at all, as you may safely open a new, empty PO file, mainly
for using these commands.  This empty PO file will slowly fill in while
you mark strings as translatable in your program sources.

`,'
     Search through program sources for a string which looks like a
     candidate for translation (`po-tags-search').

`M-,'
     Mark the last string found with `_()' (`po-mark-translatable').

`M-.'
     Mark the last string found with a keyword taken from a set of
     possible keywords.  This command with a prefix allows some
     management of these keywords (`po-select-mark-and-mark').

   The `,' (`po-tags-search') command searches for the next occurrence
of a string which looks like a possible candidate for translation, and
displays the program source in another Emacs window, positioned in such
a way that the string is near the top of this other window.  If the
string is too big to fit whole in this window, it is positioned so only
its end is shown.  In any case, the cursor is left in the PO file
window.  If the shown string would be better presented differently in
different native languages, you may mark it using `M-,' or `M-.'.
Otherwise, you might rather ignore it and skip to the next string by
merely repeating the `,' command.

   A string is a good candidate for translation if it contains a
sequence of three or more letters.  A string containing at most two
letters in a row will be considered as a candidate if it has more
letters than non-letters.  The command disregards strings containing no
letters, or isolated letters only.  It also disregards strings within
comments, or strings already marked with some keyword PO mode knows
(see below).

   If you have never told Emacs about some `TAGS' file to use, the
command will request that you specify one from the minibuffer, the
first time you use the command.  You may later change your `TAGS' file
by using the regular Emacs command `M-x visit-tags-table', which will
ask you to name the precise `TAGS' file you want to use.  *Note Tag
Tables: (emacs)Tags.

   Each time you use the `,' command, the search resumes from where it
was left by the previous search, and goes through all program sources,
obeying the `TAGS' file, until all sources have been processed.
However, by giving a prefix argument to the command (`C-u ,'), you may
request that the search be restarted all over again from the first
program source; but in this case, strings that you recently marked as
translatable will be automatically skipped.

   Using this `,' command does not prevent using of other regular Emacs
tags commands.  For example, regular `tags-search' or
`tags-query-replace' commands may be used without disrupting the
independent `,' search sequence.  However, as implemented, the
_initial_ `,' command (or the `,' command is used with a prefix) might
also reinitialize the regular Emacs tags searching to the first tags
file, this reinitialization might be considered spurious.

   The `M-,' (`po-mark-translatable') command will mark the recently
found string with the `_' keyword.  The `M-.'
(`po-select-mark-and-mark') command will request that you type one
keyword from the minibuffer and use that keyword for marking the
string.  Both commands will automatically create a new PO file
untranslated entry for the string being marked, and make it the current
entry (making it easy for you to immediately proceed to its
translation, if you feel like doing it right away).  It is possible
that the modifications made to the program source by `M-,' or `M-.'
render some source line longer than 80 columns, forcing you to break
and re-indent this line differently.  You may use the `O' command from
PO mode, or any other window changing command from Emacs, to break out
into the program source window, and do any needed adjustments.  You
will have to use some regular Emacs command to return the cursor to the
PO file window, if you want command `,' for the next string, say.

   The `M-.' command has a few built-in speedups, so you do not have to
explicitly type all keywords all the time.  The first such speedup is
that you are presented with a _preferred_ keyword, which you may accept
by merely typing `<RET>' at the prompt.  The second speedup is that you
may type any non-ambiguous prefix of the keyword you really mean, and
the command will complete it automatically for you.  This also means
that PO mode has to _know_ all your possible keywords, and that it will
not accept mistyped keywords.

   If you reply `?' to the keyword request, the command gives a list of
all known keywords, from which you may choose.  When the command is
prefixed by an argument (`C-u M-.'), it inhibits updating any program
source or PO file buffer, and does some simple keyword management
instead.  In this case, the command asks for a keyword, written in
full, which becomes a new allowed keyword for later `M-.' commands.
Moreover, this new keyword automatically becomes the _preferred_
keyword for later commands.  By typing an already known keyword in
response to `C-u M-.', one merely changes the _preferred_ keyword and
does nothing more.

   All keywords known for `M-.' are recognized by the `,' command when
scanning for strings, and strings already marked by any of those known
keywords are automatically skipped.  If many PO files are opened
simultaneously, each one has its own independent set of known keywords.
There is no provision in PO mode, currently, for deleting a known
keyword, you have to quit the file (maybe using `q') and reopen it
afresh.  When a PO file is newly brought up in an Emacs window, only
`gettext' and `_' are known as keywords, and `gettext' is preferred for
the `M-.' command.  In fact, this is not useful to prefer `_', as this
one is already built in the `M-,' command.


File: gettext.info,  Node: c-format Flag,  Next: Special cases,  Prev: Marking,  Up: Sources

Special Comments preceding Keywords
===================================

   In C programs strings are often used within calls of functions from
the `printf' family.  The special thing about these format strings is
that they can contain format specifiers introduced with `%'.  Assume we
have the code

     printf (gettext ("String `%s' has %d characters\n"), s, strlen (s));

A possible German translation for the above string might be:

     "%d Zeichen lang ist die Zeichenkette `%s'"

   A C programmer, even if he cannot speak German, will recognize that
there is something wrong here.  The order of the two format specifiers
is changed but of course the arguments in the `printf' don't have.
This will most probably lead to problems because now the length of the
string is regarded as the address.

   To prevent errors at runtime caused by translations the `msgfmt'
tool can check statically whether the arguments in the original and the
translation string match in type and number.  If this is not the case
and the `-c' option has been passed to `msgfmt', `msgfmt' will give an
error and refuse to produce a MO file.  Thus consequent use of `msgfmt
-c' will catch the error, so that it cannot cause cause problems at
runtime.

If the word order in the above German translation would be correct one
would have to write

     "%2$d Zeichen lang ist die Zeichenkette `%1$s'"

The routines in `msgfmt' know about this special notation.

   Because not all strings in a program must be format strings it is not
useful for `msgfmt' to test all the strings in the `.po' file.  This
might cause problems because the string might contain what looks like a
format specifier, but the string is not used in `printf'.

   Therefore the `xgettext' adds a special tag to those messages it
thinks might be a format string.  There is no absolute rule for this,
only a heuristic.  In the `.po' file the entry is marked using the
`c-format' flag in the `#,' comment line (*note PO Files::).

   The careful reader now might say that this again can cause problems.
The heuristic might guess it wrong.  This is true and therefore
`xgettext' knows about a special kind of comment which lets the
programmer take over the decision.  If in the same line as or the
immediately preceding line to the `gettext' keyword the `xgettext'
program finds a comment containing the words `xgettext:c-format', it
will mark the string in any case with the `c-format' flag.  This kind
of comment should be used when `xgettext' does not recognize the string
as a format string but it really is one and it should be tested.
Please note that when the comment is in the same line as the `gettext'
keyword, it must be before the string to be translated.

   This situation happens quite often.  The `printf' function is often
called with strings which do not contain a format specifier.  Of course
one would normally use `fputs' but it does happen.  In this case
`xgettext' does not recognize this as a format string but what happens
if the translation introduces a valid format specifier?  The `printf'
function will try to access one of the parameters but none exists
because the original code does not pass any parameters.

   `xgettext' of course could make a wrong decision the other way
round, i.e. a string marked as a format string actually is not a format
string.  In this case the `msgfmt' might give too many warnings and
would prevent translating the `.po' file.  The method to prevent this
wrong decision is similar to the one used above, only the comment to
use must contain the string `xgettext:no-c-format'.

   If a string is marked with `c-format' and this is not correct the
user can find out who is responsible for the decision.  See *Note
xgettext Invocation:: to see how the `--debug' option can be used for
solving this problem.


File: gettext.info,  Node: Special cases,  Prev: c-format Flag,  Up: Sources

Special Cases of Translatable Strings
=====================================

   The attentive reader might now point out that it is not always
possible to mark translatable string with `gettext' or something like
this.  Consider the following case:

     {
       static const char *messages[] = {
         "some very meaningful message",
         "and another one"
       };
       const char *string;
       ...
       string
         = index > 1 ? "a default message" : messages[index];
     
       fputs (string);
       ...
     }

   While it is no problem to mark the string `"a default message"' it
is not possible to mark the string initializers for `messages'.  What
is to be done?  We have to fulfill two tasks.  First we have to mark the
strings so that the `xgettext' program (*note xgettext Invocation::)
can find them, and second we have to translate the string at runtime
before printing them.

   The first task can be fulfilled by creating a new keyword, which
names a no-op.  For the second we have to mark all access points to a
string from the array.  So one solution can look like this:

     #define gettext_noop(String) String
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message"),
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext ("a default message") : gettext (messages[index]);
     
       fputs (string);
       ...
     }

   Please convince yourself that the string which is written by `fputs'
is translated in any case.  How to get `xgettext' know the additional
keyword `gettext_noop' is explained in *Note xgettext Invocation::.

   The above is of course not the only solution.  You could also come
along with the following one:

     #define gettext_noop(String) String
     
     {
       static const char *messages[] = {
         gettext_noop ("some very meaningful message",
         gettext_noop ("and another one")
       };
       const char *string;
       ...
       string
         = index > 1 ? gettext_noop ("a default message") : messages[index];
     
       fputs (gettext (string));
       ...
     }

   But this has a drawback.  The programmer has to take care that he
uses `gettext_noop' for the string `"a default message"'.  A use of
`gettext' could have in rare cases unpredictable results.

   One advantage is that you need not make control flow analysis to make
sure the output is really translated in any case.  But this analysis is
generally not very difficult.  If it should be in any situation you can
use this second method in this situation.


File: gettext.info,  Node: Template,  Next: Creating,  Prev: Sources,  Up: Top

Making the PO Template File
***************************

   After preparing the sources, the programmer creates a PO template
file.  This section explains how to use `xgettext' for this purpose.

   `xgettext' creates a file named `DOMAINNAME.po'.  You should then
rename it to `DOMAINNAME.pot'.  (Why doesn't `xgettext' create it under
the name `DOMAINNAME.pot' right away?  The answer is: for historical
reasons.  When `xgettext' was specified, the distinction between a PO
file and PO file template was fuzzy, and the suffix `.pot' wasn't in
use at that time.)

* Menu:

* xgettext Invocation::         Invoking the `xgettext' Program

